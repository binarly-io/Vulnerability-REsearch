# [BRLY-2021-037]

# SMM memory corruption vulnerability in SMM driver on multiple HP devices.

## Summary

**BINARLY efiXplorer team** has discovered a SMM memory corruption vulnerability on multiple HP devices allowing a possible attacker to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-037
* HP PSIRT assigned CVE identifier: [CVE-2022-23929](https://support.hp.com/us-en/document/ish_5817864-5817896-16)
* CERT/CC assigned case number: VU#683814
* CVSS v3.1 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected HP firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| [Device](https://support.hp.com/us-en/drivers/selfservice/hp-prodesk-405-g6-small-form-factor-pc/38230306) / firmware version: `02.05.01 Rev.A` | FFFF | e16440e9e87d0024404999cfac3806a67ee3ab42631cb810a85dd7cda247308b | F66AC4DD-F73D-4252-A6B4-8A48E11FE99C |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in the SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in child the SW SMI handler registered with GUID `79da6e76-2e45-46e9-b53d-03afbef44844` and located at offset `0x1810` in the driver.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler_1810(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        CommBufferStruct *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( CommBuffer && CommBufferSize && *CommBufferSize == 24 && CommBuffer->BufferPtr && CommBuffer->BufferSize )
  {
    Res = 0;
    if ( CommBuffer->BufferSize )
      Res = SmmIsBufferOutsideSmmValid(CommBuffer->BufferPtr, CommBuffer->BufferSize);
    if ( (-(Res == 0) & EFI_SECURITY_VIOLATION) == 0 )
    {
      if ( LOBYTE(CommBuffer->Case) )
      {
        if ( LOBYTE(CommBuffer->Case) != 1 )
        {
          Status = EFI_INVALID_PARAMETER;
_Exit:
          CommBuffer->Status = Status;
          return 0;
        }
      }
      else
      {
        gPointer = &gData;
      }
      // SMM memory corruption here
      Status = sub_189C(CommBuffer->BufferPtr);
      goto _Exit;
    }
  }
  return 0;
}
```

In this case the `CommBuffer` has the following structure:

```
00000000 CommBufferStruct struc ; (sizeof=0x18, mappedto_235)
00000000 BufferPtr       dq ?
00000008 BufferSize      dd ?
0000000C Case            dd ?
00000010 Status          dq ?
00000018 CommBufferStruct ends
```

As we can see, the nested pointer `CommBuffer->BufferPtr` with size `CommBuffer->BufferSize` is validated (checking that it does not overlap with SMRAM).
But `CommBuffer->BufferSize` is only compared to zero, not the expected fixed value.
This means that an attacker can set the `CommBuffer->BufferSize` value to `1` and then the `SmmIsBufferOutsideSmmValid` function will check that only the first byte does not overlap with SMRAM.

The pseudocode of the function `sub_189C` shown below:

```c++
EFI_STATUS __fastcall sub_189C(char *Buffer)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  DstBuffer = Buffer;
  Status0 = EFI_INVALID_PARAMETER;
  Index = 0;
  if ( Buffer )
  {
    // Change the data pointed to by CommBuffer->BufferPtr
    ZeroMem(Buffer, 0x260);
    Status = EFI_SUCCESS;
    do
    {
      if ( Status )
        break;
      Status = EFI_INVALID_PARAMETER;
      if ( DstBuffer )
      {
        Value = Dref(&gData, gPointer);
        if ( Value == &gData )
        {
          Status = EFI_NOT_FOUND;
        }
        else
        {
          SrcBuffer = Value + 16;
          gPointer = Value;
          if ( Value != -16 && DstBuffer != SrcBuffer )
            // Change the data pointed to by CommBuffer->BufferPtr
            CopyMem(DstBuffer, SrcBuffer, 38);
          Status = EFI_SUCCESS;
        }
      }
      DstBuffer += 38;
      ++Index;
    }
    while ( Index < 0x10u );
    Status0 = Status;
    if ( Status == EFI_NOT_FOUND )
      return 0;
  }
  return Status0;
}
```

As we can see from the pseudocode, the data pointed to by `CommBuffer->BufferPtr` is overwritten in two places.
Suppose that `CommBuffer->BufferSize` is `1` and `CommBuffer->BufferPtr` points to `(SMRAM_BASE - 1)`.
It mean that an attacker can potentially corrupt some structures at the beginning of the SMRAM.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| HP PSIRT is notified                     | 2021-07-12    |
| HP PSIRT confirmed reported issue        | 2021-08-09    |
| HP PSIRT assigned CVE number             | 2021-08-19    |
| CERT/CC created a case                   | 2021-11-16    |
| HP PSIRT provide patch release           | 2022-03-08    |
| BINARLY public disclosure date           | 2022-03-08    |

## Acknowledgements

**BINARLY efiXplorer team**
