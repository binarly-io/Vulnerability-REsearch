# [BRLY-2021-051]

*Reported as a part of [Intel Camping with Tigers bug bounty program](https://www.projectcircuitbreaker.com/camping-with-tigers)*

# SMM memory corruption vulnerability in SMM driver on Intel platforms.

## Summary

**BINARLY efiXplorer team** has discovered SMM memory corruption vulnerability on Intel platforms allowing a possible attacker to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-051
* Intel PSIRT assigned CVE identifier: [CVE-2022-23955](https://support.hp.com/us-en/document/ish_5661066-5661090-16)
* CVSS v3.1: 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| HP EliteBook x360 1040 G8 | 0169 | 4140f347c52cc1a288e6b517a18b6b6434d6085211977dc76a02fc1322db9425 | D80ECBF5-49B2-45AF-80B7-7D3C226E6741 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an evironment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in child SW SMI handler registered with GUID `a7149597-ca0a-4ff5-a12e-5e5deb1051c8` and located at offset `0x1A24` in the binary.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Interface = 0;
  if ( CommBuffer && CommBufferSize )
  {
    Res = gSmst->SmmLocateProtocol(&ProprietaryProtocol_8, 0, &Interface);
    if ( !Res )
      Res = (*Interface)();
    *CommBuffer = Res;
  }
  return 0;
}
```

Before SMI handler will be triggered, CommBuffer will be checked for overlap with SMRAM (inside `PiSmmCommunicationSmm` module):

```c++
EFI_STATUS __fastcall SwSmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Status = 0;
  CommunicationHeader = *gCommunicationHeader;
  if ( *gCommunicationHeader )
  {
    if ( SmmIsBufferOutsideSmmValid(*gCommunicationHeader, 24) )
    {
      CommBufferSizea[0] = CommunicationHeader->MessageLength;
      if ( SmmIsBufferOutsideSmmValid(CommunicationHeader->Data, CommBufferSizea[0]) )
        Status = gSmst->SmiManage(
                   &CommunicationHeader->HeaderGuid,
                   0,
                   CommunicationHeader->Data,
                   CommBufferSizea);
    }
  }
  return -(Status != 0) & 0xA000000000000000;
}
```

If `CommunicationHeader->MessageLength` is `0` and `CommunicationHeader->Data` does not overlap with SMRAM, check will pass.

As we can see from the pseudocode, `*CommBufferSize` is not checked (only the `CommBufferSize` pointer is compared to NULL).
But at the same time there is a primitive for writing 8 fixed bytes at the address of `CommBuffer`:

This leads to rewriting pointed area with a predictable data - Status code.

As we can see from header of SMRAM dump, first 8 bytes of SMRAM is signature (`SMMS3_64`).

```
$ xxd SMRAM_dump_8b000000_8b7fffff.bin | head
00000000: 534d 4d53 335f 3634 8029 7d8b 0000 0000  SMMS3_64.)}.....
...
```

Thus, a potential attacker cannot execute arbitrary code, but can carry out a DOS attack.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Intel PSIRT is notified                  | 2022-01-05    |
| HP PSIRT provide patch release           | 2022-03-15    |
| BINARLY public disclosure date           | 2022-05-23    |

## Acknowledgements

**BINARLY efiXplorer team**
