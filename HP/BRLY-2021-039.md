# [BRLY-2021-039]

# The heap buffer overflow vulnerability in child SW SMI handler on multiple HP devices.

## Summary

**BINARLY efiXplorer team** has discovered a heap buffer overflow vulnerability in child SW SMI handler on multiple HP devices that allow corrupt heap metadata.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-039
* HP PSIRT assigned CVE identifier: [CVE-2022-23931](https://support.hp.com/us-en/document/ish_5817864-5817896-16)
* CERT/CC assigned case number: VU#683814
* CVSS v3.1 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected HP firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| [Device](https://support.hp.com/us-en/drivers/selfservice/hp-prodesk-405-g6-small-form-factor-pc/38230306) / firmware version: `02.05.01 Rev.A` | 0511 | 0c490900ab673a1cb54828b4c80681fa140ca4fe35cbd7ea5be7a87c3d527652 | 0D966D65-8F25-4574-8EAF-6C0463F38742 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in the SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in the child SW SMI handler registered with GUID `807ca9f6-216c-4cbc-87f7-3cd555887208` and located at offset `0x17C8` in the driver.

The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler_17C8(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        CommBufferStruct *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( CommBuffer )
  {
    if ( CommBufferSize )
    {
      Size = *CommBufferSize;
      if ( (-(*CommBufferSize != 160) & EFI_INVALID_PARAMETER) == 0 )
      {
        Res = 0;
        if ( Size )
          Res = SmmIsBufferOutsideSmmValid(CommBuffer, Size);
        if ( (-(Res == 0) & EFI_INVALID_PARAMETER) == 0 )
        {
          Status = -(CommBuffer->Sig != 'GFCU') & EFI_INVALID_PARAMETER;
          if ( CommBuffer->Sig == 'GFCU' )
          {
            if ( CommBuffer->Case == 16 )
            {
              if ( !gBufferPtr1 )
              {
                BufferPtr1 = GetCopy(120, &CommBuffer->BufferPtr1);
                BufferSize = CommBuffer->BufferSize;
                BufferPtr = CommBuffer->BufferPtr;
                gBufferPtr1 = BufferPtr1;
                // Vulnerability here
                sub_2288(BufferPtr, BufferSize);
                PcdProtocol = BsLocatePcdProtocol();
                if ( (PcdProtocol->Get8)(0x2C4) == 1 )
                  HandlerUnregister();
              }
            }
            ...
          }
          ...
        }
      }
    }
  }
  return 0;
}
```

In this case the `CommBuffer` has the following structure:

00000000 CommBufferStruct struc ; (sizeof=0xA0, mappedto_234)
00000000 Sig             dd ?
00000004 Case            dd ?
00000008 BufferPtr       dq ?
00000010 BufferSize      dq ?
00000018 BufferPtr1      dd ?
...
00000098 Status          dq ?

If `CommBuffer->Sig == 0x47464355 && CommBuffer->Case == 16 && !CommBuffer->BufferPtr1` following code will trigger:

```c++
BufferPtr1 = GetCopy(120, &CommBuffer->BufferPtr1);
BufferSize = CommBuffer->BufferSize;
BufferPtr = CommBuffer->BufferPtr;
gBufferPtr1 = BufferPtr1;
// Vulnerability here
sub_2288(BufferPtr, BufferSize);
PcdProtocol = BsLocatePcdProtocol();
if ( (PcdProtocol->Get8)(0x2C4) == 1 )
  HandlerUnregister();
```

Below is the pseudocode of the `sub_2288` function:

```c++
__int64 __fastcall sub_2288(__int64 Buffer, __int64 Size)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Model = CheckFamilyAndModel();
  if ( ((Model - 12) & 0xFFFFFFFFFFFFFFFD) == 0 )
  {
    gBufferCopy = GetCopy(Size, Buffer);        // Get copy of Buffer on heap
    Copy = GetCopy(16 * (*gBufferCopy + *(gBufferCopy + 1)), gBufferCopy[1]);
    BufferCopy = gBufferCopy;
    Byte3 = *(gBufferCopy + 3);
    gBufferCopy[1] = Copy;                      // OOB Write if Size < 16
    Data = GetCopy(16 * (*(BufferCopy + 2) + Byte3), BufferCopy[2]);
    BufferCopy2 = gBufferCopy;
    goto _Exit;
  }
  if ( ((Model - 8) & 0xFFFFFFFFFFFFFFFC) == 0 && Model != 9 )
  {
    gBufferCopy1 = GetCopy(Size, Buffer);       // Get copy of Buffer on heap
    Copy1 = GetCopy(16 * (*gBufferCopy1 + *(gBufferCopy1 + 1)), gBufferCopy1[1]);
    BufferCopy1 = gBufferCopy1;
    Byte31 = *(gBufferCopy1 + 3);
    gBufferCopy1[1] = Copy1;                    // OOB Write if Size < 16
    Data = GetCopy(16 * (*(BufferCopy1 + 2) + Byte31), BufferCopy1[2]);
    BufferCopy2 = gBufferCopy1;
_Exit:
    BufferCopy2[2] = Data;                      // OOB Write if Size < 24
  }
  return 0;
}
```

`GetCopy` will allocate a buffer of size `*CommBufferSize` and copy the contents of the `CommBuffer` into this buffer:

```c++
void *__fastcall GetCopy(UINTN Size, const void *Buffer)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  result = AllocatePool(Size); // gSmst->SmmAllocatePool wrapper
  if ( result && Size && result != Buffer )
    return CopyMem(result, Buffer, Size);
  return result;
}
```

A potential attacker controls `Size` (` Buffer Size-BufferSize`). It means that the attacker controls the size of buffer allocated in `GetCopy` function.

But in the `sub_2288` function there are 3 pieces of code in which data is written to the allocated buffer at fixed offsets which may be larger than the `Size` (size of the buffer):

* `gBufferCopy[1] = Copy; // OOB Write if Size < 16`
* `gBufferCopy1[1] = Copy1; // OOB Write if Size < 16`
* `BufferCopy2[2] = Data; // OOB Write if Size < 24`

It should be noted that this handler must unregister the first time it is called. This means that the vulnerability cannot be exploited from the operating system. However, this vulnerability can be exploited at the DXE stage if a vulnerability exists that allows arbitrary code to be executed in the DXE (there are several such vulnerabilities in this firmware).

To exploit this vulnerability it is enough to:

1. Set up a Communication Buffer:

    * CommBuffer->Sig = 0x47464355 (`"GFCU"`)
    * CommBuffer->Case = 16
    * CommBuffer->BufferPtr1 = 0
    * CommBuffer->BufferPtr = {any valid pointer}
    * CommBuffer->BufferSize = {number from 1 to 15}

2. Trigger the SW SMI Handler (SW SMI number and pointer to Communication Buffer are specified in UEFI ACPI table) via `0xB2` IO port.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| HP PSIRT is notified                     | 2021-07-12    |
| HP PSIRT confirmed reported issue        | 2021-08-09    |
| HP PSIRT assigned CVE number             | 2021-08-19    |
| CERT/CC created a case                   | 2021-11-16    |
| HP PSIRT provide patch release           | 2022-03-08    |
| BINARLY public disclosure date           | 2022-03-08    |

## Acknowledgements

**BINARLY efiXplorer team**
