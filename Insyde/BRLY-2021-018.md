# [BRLY-2021-018]

# SMM callout vulnerability in combined DXE/SMM on Fujitsu device (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified a SMM callout in a Fujitsu device, which allows an attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-018
* CERT/CC assigned case number: [VU#796611](https://kb.cert.org/vuls/id/796611)
* Insyde PSIRT assigned CVE identifier: [CVE-2021-41841](https://www.insyde.com/security-pledge/SA-2022019)
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Fujitsu firmware with confirmed impact by BINARLY team

| Device name | Driver name | Driver SHA256 | File GUID |
| --- | --- | --- | --- |
| Fujitsu LIFEBOOK E459/E449 | AhciBusDxe | 4143f3774dd14fcfc1afc3d7ee774f97e4ca556032bbc7c3133f5ba9b0045402 | 3ACC966D-8E33-45C6-B4FE-62724BCD15A9 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability could potentially be used by threat actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

In the function at offset `0x1068` (image sha256: `4143f3774dd14fcfc1afc3d7ee774f97e4ca556032bbc7c3133f5ba9b0045402`), the child software System Management Interrupt (SWSMI) handler with the GUID `56947330-585c-4470-a95d-c55c529feb47` is registered:

```c++
if ( SmstIsNotNull() )
{
  Handle1 = 0;
  gBS_E738->InstallProtocolInterface(&Handle1, &ProprietaryProtocol_D8C0, EFI_NATIVE_INTERFACE, 0);
  gHandle = Handle;
  return gSmst_E718->SmiHandlerRegister(SmiHandler_1C10, &gSmiHandlerGuid, &DispatchHandle);
}
```

Find below the decompiled SWSMI handler code:

```c++
EFI_STATUS __fastcall SmiHandler_1C10(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( CommBuffer && CommBufferSize )
  {
    if ( *CommBuffer == 1 )
    {
      Buffer = 0;
      if ( gBS_E738->LocateHandleBuffer(ByProtocol, &EFI_ATA_PASS_THRU_PROTOCOL_GUID_D660, 0, &NoHandles, &Buffer) )
      {
        Status = EFI_NOT_FOUND;
      }
      else
      {
        Buffer = 0;
        BufferSize = 0;
        v6 = gSmst_E718->SmmLocateHandle(ByProtocol, &EFI_ATA_PASS_THRU_PROTOCOL_GUID_D660, 0, &BufferSize, 0);
        Status = EFI_NOT_FOUND;
        if ( v6 )
        {
          if ( v6 == EFI_BUFFER_TOO_SMALL )
          {
            gSmst_E718->SmmAllocatePool(EfiRuntimeServicesData, BufferSize, &Buffer);
            if ( !Buffer )
            {
              Status = 0x8000000000000009;
              goto _WriteStatus;
            }
            v6 = gSmst_E718->SmmLocateHandle(
                   ByProtocol,
                   &EFI_ATA_PASS_THRU_PROTOCOL_GUID_D660,
                   0,
                   &BufferSize,
                   Buffer);
          }
          else if ( v6 != EFI_NOT_FOUND )
          {
            goto _WriteStatus;
          }
        }
        if ( v6 == EFI_NOT_FOUND )
          v7 = 0;
        else
          v7 = BufferSize >> 3;
        gSmst_E718->SmmFreePool(Buffer);
        if ( v7 == NoHandles )
          goto _SetEfiSuccessStatus;
        if ( !Handle )
        {
          Status = EFI_NOT_READY;
          goto _WriteStatus;
        }
        Status = sub_1E6C();
        if ( !Status )
        {
          Status = gBS_E738->HandleProtocol(Handle, &EFI_LOADED_IMAGE_PROTOCOL_GUID_D710, &Interface);
          if ( !Status )
          {
            Interface->Unload = sub_2C74;
            if ( !gBS_E738->LocateProtocol(&EFI_ACPI_SUPPORT_PROTOCOL_GUID_D6E0, 0, &v15) )
            {
              v8 = 0;
              do
              {
                v9 = (v15->GetAcpiTable)(v15, v8, &v16, &v18, v17);
                if ( !v9 )
                {
                  if ( *v16 == 'PCAF' )
                  {
                    v9 = EFI_ABORTED;
                    dword_E6E0 = *(v16 + 19);
                  }
                  gBS_E738->FreePool(v16);
                }
                ++v8;
              }
              while ( !v9 );
            }
          }
          goto _WriteStatus;
        }
        if ( Status == EFI_NOT_STARTED )
_SetEfiSuccessStatus:
          Status = EFI_SUCCESS;
      }
    }
    else
    {
      Status = EFI_UNSUPPORTED;
    }
_WriteStatus:
    *(CommBuffer + 1) = Status;
  }
  return 0;
}
```

If `CommBuffer` and `CommBufferSize` pointers are not-NULL and first QWORD from `CommBuffer` is equal to `0x01`, the following code will be executed:

```c++
Buffer = 0;
if ( gBS_E738->LocateHandleBuffer(ByProtocol, &EFI_ATA_PASS_THRU_PROTOCOL_GUID_D660, 0, &NoHandles, &Buffer) )
{
  Status = EFI_NOT_FOUND;
}
```

Using services from `EFI_BOOT_SERVICES` (in this case `LocateHandleBuffer()`) inside a SW SMI handler is unsafe and may lead to arbitrary code execution in SMM.

In addition to this code, this SMI handler uses many other services from the `EFI_BOOT_SERVICES` and `EFI_RUNTIME_SERVICES` tables.

An example of using the `LocateProtocol()` (from `EFI_BOOT_SERVICES`) and `GetVariable()` (from `EFI_RUNTIME_SERVICES`) services is shown below (`SmiHandler_1C10()` -> `sub_1E6C()`):

```c++
EFI_STATUS sub_1E6C()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Interface = 0;
  v0 = 0;
  if ( !gBS_E738->LocateProtocol(&EFI_SMM_RUNTIME_PROTOCOL_GUID_D630, 0, &Interface) )
    (*Interface)(&EFI_SMM_RUNTIME_PROTOCOL_GUID_D630, 0, &Interface);
  v1 = ::Buffer;
  v2 = 0;
  if ( ::Buffer )
  {
    DataSize = 0;
    Status = gRT_E740->GetVariable(VariableName, &EFI_GENERIC_VARIABLE_GUID_D540, 0, &DataSize, 0);
    if ( Status == EFI_BUFFER_TOO_SMALL )
    {
      Data = SmmAllocatePool(DataSize);
      v2 = Data;
      if ( Data )
        Status = (gRT_E740->GetVariable)(VariableName, &EFI_GENERIC_VARIABLE_GUID_D540, 0, &DataSize, Data);
    }
    ...
  }
  ...
  return result;
}
```

Each of these services can be targeted by a potential attacker. 

To exploit this vulnerability is enough to:

* overwrite the service address in the `EFI_BOOT_SERVICES` (or `EFI_RUNTIME_SERVICES`) table with the shellcode address
* trigger the SWSMI handler (SwSmi number is specified in UEFI ACPI table)

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Fujitsu PSIRT is notified                | 2021-09-10    |
| Fujitsu PSIRT is confirmed issue         | 2021-09-14    |
| CERT/CC created a case                   | 2021-09-27    |
| Insyde PSIRT assigned CVE number         | 2021-11-01    |
| Insyde PSIRT provide patch release       | 2021-11-09    |
| BINARLY public disclosure date           | 2022-02-01    |

## Acknowledgements

**BINARLY efiXplorer team**
