# [BRLY-LOGOFAIL-2023-013]

# Memory contents leak / information disclosure vulnerability in DXE driver.

## Summary

**BINARLY efiXplorer team** has discovered a memory contents leak / information disclosure vulnerability. Image->ImageOffset is not validated during parsing of arbitrary BMP file on AMI firmware. The attacker can make it as high as 0xFFFFFFFF and thus display the contents of physical memory (in the form of pixels).

## Vulnerability Information

- BINARLY internal vulnerability identifier: BRLY-LOGOFAIL-2023-013
- AMI PSIRT assigned CVE identifier: CVE-2023-39538
- CVSS v3.1: 6.0 Medium AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N

## Affected modules with confirmed impact by Binarly team

| Module name   | Module GUID                          | Module SHA256                                                    |
| ------------- | ------------------------------------ | ---------------------------------------------------------------- |
| AMITSE        | b1da0adf-4f77-4070-a88e-bffe1c60529a | 439e73d391b7f7540f6faa58afdc2722bda250468d4a4f7f5f84228c1f77ddbe |

## Potential impact

An attacker with local privileged access can exploit this vulnerability to read the contents of the physical memory and use this information to exploit other vulnerabilities in DXE. A malicious code installed as a result of the vulnerability exploitation in a DXE driver could survive across an operating system (OS) boot process and runtime or modify NVRAM area on SPI flash storage (to gain persistence on target platform). Additionally, this vulnerability potentially could be used by threat actors to bypass OS security mechanisms (modify privileged memory or runtime variables), influence on the OS boot process, and in some cases would allow an attacker to hook or modify EFI Runtime services.

## Vulnerability description

The pseudocode of the vulnerable function is shown below:

```c
unsigned __int64 __fastcall DecodeBMP(
        BMP_IMAGE_HEADER *Image,
        __int64 ImageSize,
        __int64 *a3,
        unsigned __int64 *a4,
        unsigned __int64 *a5,
        unsigned __int64 *a6)
{
  CHAR8 *v8; // rdi
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rax
  __int64 v11; // rax
  unsigned __int64 v13; // r11
  unsigned __int64 PixelWidth; // rdx
  unsigned __int64 PixelHeight; // rcx
  unsigned __int64 v16; // r10
  __int64 v17; // rsi
  unsigned __int64 v18; // r9
  CHAR8 *v19; // r8
  CHAR8 v20; // al
  CHAR8 v21; // al
  unsigned __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rcx
  CHAR8 CharB; // al
  UINT32 ImageOffset; // eax

  if ( *(_WORD *)&Image->CharB != 'MB' )
    return 0x8000000000000003ui64;
  if ( Image->CompressionType )
    return 0x8000000000000003ui64;
  // BRLY-LOGOFAIL-2023-013  
  v8 = &Image->CharB + Image->ImageOffset;
  v9 = Image->PixelWidth * (unsigned __int64)Image->PixelHeight;
  if ( v9 >= 0x40000000 )
    return 0x8000000000000003ui64;
  v10 = 4 * v9;
  if ( *a3 )
  {
    if ( *a4 < v10 )
    {
      *a4 = v10;
      return 0x8000000000000005ui64;
    }
  }
  else
  {
    *a4 = v10;
    v11 = sub_500C(4 * v9);
    *a3 = v11;
    if ( !v11 )
      return 0x8000000000000009ui64;
  }
  v13 = 0i64;
  PixelWidth = Image->PixelWidth;
  PixelHeight = Image->PixelHeight;
  v16 = PixelWidth;
  v17 = *a3;
  *a6 = PixelWidth;
  *a5 = PixelHeight;
  if ( (_DWORD)PixelHeight )
  {
    do
    {
      v18 = 0i64;
      v19 = (CHAR8 *)(v17 + 4 * v16 * (PixelHeight - v13 - 1));
      if ( (_DWORD)PixelWidth )
      {
        do
        {
          switch ( Image->BitPerPixel )
          {
            case 1u:
              v24 = 8i64;
              do
              {
                if ( ((unsigned __int8)(1 << --v24) & (unsigned __int8)*v8) != 0 )
                {
                  v19[2] = Image[1].Reserved[0];
                  v19[1] = HIBYTE(Image[1].Size);
                  CharB = BYTE2(Image[1].Size);
                }
                else
                {
                  v19[2] = Image[1].Size;
                  v19[1] = Image[1].CharM;
                  CharB = Image[1].CharB;
                }
                *v19 = CharB;
                if ( v18 < Image->PixelWidth )
                {
                  v19 += 4;
                  ++v18;
                }
              }
              while ( v24 );
              v19 -= 4;
              --v18;
              break;
            case 4u:
              v22 = (unsigned __int64)(unsigned __int8)*v8 >> 4;
              v19[2] = *((_BYTE *)&Image[1].Size + 4 * v22);
              v19[1] = *(&Image[1].CharM + 4 * v22);
              *v19 = *(&Image[1].CharB + 4 * v22);
              if ( v18 < Image->PixelWidth - 1 )
              {
                v19 += 4;
                ++v18;
                v23 = *v8 & 0xF;
                v19[2] = *((_BYTE *)&Image[1].Size + 4 * v23);
                v19[1] = *(&Image[1].CharM + 4 * v23);
                *v19 = *(&Image[1].CharB + 4 * v23);
              }
              break;
            case 8u:
              v19[2] = *((_BYTE *)&Image[1].Size + 4 * (unsigned __int8)*v8);
              v19[1] = *(&Image[1].CharM + 4 * (unsigned __int8)*v8);
              *v19 = *(&Image[1].CharB + 4 * (unsigned __int8)*v8);
              break;
            case 0x18u:
              *v19 = *v8;
              v21 = v8[1];
              v8 += 2;
              v19[1] = v21;
              v19[2] = *v8;
              break;
            default:
              if ( Image->BitPerPixel != 32 || Image->CompressionType )
                return 0x8000000000000003ui64;
              *v19 = *v8;
              v19[1] = v8[1];
              v20 = v8[2];
              v8 += 3;
              v19[2] = v20;
              break;
          }
          PixelWidth = Image->PixelWidth;
          ++v18;
          ++v8;
          v19 += 4;
          v16 = PixelWidth;
        }
        while ( v18 < PixelWidth );
      }
      ImageOffset = Image->ImageOffset;
      if ( (((_BYTE)v8 - (_BYTE)ImageOffset) & 3) != 0 )
        v8 += 4i64 - (((_BYTE)v8 - (_BYTE)ImageOffset) & 3);
      PixelHeight = Image->PixelHeight;
      ++v13;
    }
    while ( v13 < PixelHeight );
  }
  return 0i64;
}
```

As we can see from the pseudocode, `Image->ImageOffset` is not validated. The attacker can make it as high as `0xFFFFFFFF` and thus display the contents of physical memory (in the form of pixels) at any offset.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                    | Date (YYYY-mm-dd) |
| -------------------------------------- | ----------------- |
| Lenovo PSIRT is notified               | 2023-06-21        |
| Lenovo ID (LEN-132940) is assigned     | 2023-06-22        |
| CERT/CC is notified                    | 2023-07-10        |
| AMI PSIRT confirmed reported issues 	 | 2023-10-05        |
| AMI PSIRT assigned CVE ID 	           | 2023-12-01        |
| BINARLY public disclosure date         | 2024-06-19        |

## Acknowledgements

**BINARLY efiXplorer team**
