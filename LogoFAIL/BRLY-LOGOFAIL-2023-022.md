# [BRLY-LOGOFAIL-2023-022]

# Memory Corruption vulnerability in DXE driver.

## Summary

**BINARLY efiXplorer team** has discovered a lack of validation on number of Huffamn tables that leads to OOB Write operations during JPEG file processing in AMI firmware.

## Vulnerability Information

- BINARLY internal vulnerability identifier: BRLY-LOGOFAIL-2023-022
- AMI PSIRT assigned CVE identifier: CVE-2023-39538
- CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H 

## Affected modules with confirmed impact by Binarly team

| Module name   | Module GUID                          | Module SHA256                                                    |
| ------------- | ------------------------------------ | ---------------------------------------------------------------- |
| AMITSE        | b1da0adf-4f77-4070-a88e-bffe1c60529a | 439e73d391b7f7540f6faa58afdc2722bda250468d4a4f7f5f84228c1f77ddbe |

## Potential impact

An attacker with local access can exploit this vulnerability to elevate privileges from ring 3 or ring 0 (depends on the operating system) to a DXE driver and execute arbitrary code. Malicious code installed as a result of this exploitation could survive operating system (OS) boot process and runtime, or modify NVRAM area on the SPI flash storage (to gain persistence). Additionally, threat actors could use this vulnerability to bypass OS security mechanisms (modify privileged memory or runtime variables), influence OS boot process, and in some cases allow an attacker to hook or modify EFI Runtime services.

## Vulnerability description

The pseudocode of the vulnerable function is shown below:

```c
__int64 __fastcall GetDimensions(_BYTE *Image)
{
  char v2; // di
  unsigned __int8 HuffmanTablesCounter; // r10
  unsigned __int8 v4; // bl
  unsigned __int8 MarkerType; // cl
  __int64 v6; // rax
  __int64 v8; // rax
  char v9; // al
  _BYTE *v10; // rdx
  _QWORD *v11; // r8
  unsigned __int8 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // r11
  unsigned __int16 Len; // [rsp+30h] [rbp+8h]

  v2 = 0;
  HuffmanTablesCounter = 0;
  v4 = 0;
  if ( *Image != 0xFF || Image[1] != 0xD8 )
    return 0i64;
  while ( 1 )
  {
    MarkerType = Image[1];
    if ( MarkerType != 0xD8 )
      break;
    Image += 2;
LABEL_27:
    if ( *Image != 0xFF )
      return 0i64;
  }
  if ( MarkerType == 0xD9 )
    goto LABEL_30;
  if ( !MarkerType )
    return 0i64;
  if ( (MarkerType & 0xF0) == 0xE0 )
  {
LABEL_26:
    v9 = Image[3];
    v10 = Image + 2;
    LOBYTE(Len) = v9;
    HIBYTE(Len) = *v10;
    Image = &v10[Len];
    goto LABEL_27;
  }
  if ( MarkerType == 0xC0 )
  {
    v2 |= 2u;
    qword_95FC0 = (Image + 2);
    goto LABEL_26;
  }
  if ( MarkerType == 0xC4 )                     // Huffman Table Marker
  {
    v6 = HuffmanTablesCounter++;
    HuffmanTables[v6] = (Image + 4);
    goto LABEL_26;
  }
  if ( (MarkerType & 0xF0) == 0xC0 )
  {
    if ( MarkerType > 0xC0u && MarkerType < 0xD0u )
      return 0i64;
    goto LABEL_26;
  }
  if ( MarkerType != 0xDA )
  {
    if ( MarkerType == 0xDB )
    {
      v8 = v4++;
      qword_95EA0[v8] = (Image + 4);
    }
    else if ( MarkerType == 0xDD )
    {
      LOBYTE(word_95490) = Image[5];
      HIBYTE(word_95490) = Image[4];
    }
    else if ( (MarkerType & 0xF8) != 0xD0
           && (MarkerType == 0xDC || MarkerType == 0xDE || MarkerType == 0xDF || (MarkerType + 16) > 0xEu) )
    {
      return 0i64;
    }
    goto LABEL_26;
  }
  qword_95F10 = (Image + 14);
LABEL_30:
  if ( v4 == 1 )
  {
    v4 = 2;
    qword_95EA8 = qword_95EA0[0] + 65;
  }
  if ( HuffmanTablesCounter == 1 )
  {
    v11 = &unk_96568;
    do
    {
      v12 = 0;
      v13 = 0i64;
      v14 = HuffmanTables[HuffmanTablesCounter - 1];
      do
        v12 += *(v14 + v13++ + 1);
      while ( v13 < 16 );
      ++HuffmanTablesCounter;
      *v11++ = v12 + v14 + 17;
    }
    while ( HuffmanTablesCounter < 4u );
  }
  if ( HuffmanTablesCounter != 4 || v4 != 2 || (v2 & 2) == 0 )
    return 0i64;
  sub_5D26C(2u, 4u);
  return 1i64;
}
```

As we can see from the pseudocode, the JPEG parser found in AMI firmware assumes that a JPEG image can contain only 4 Huffman table, since the `HuffmanTables` array is statically allocated with size. By storing more than 4 Huffman table in a JPEG image, the attacker can leverage this vulnerability to overwrite global data.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                    | Date (YYYY-mm-dd) |
| -------------------------------------- | ----------------- |
| Lenovo PSIRT is notified               | 2023-06-21        |
| Lenovo ID (LEN-132940) is assigned     | 2023-06-22        |
| CERT/CC is notified                    | 2023-07-10        |
| AMI PSIRT confirmed reported issues 	 | 2023-10-05        |
| AMI PSIRT assigned CVE ID 	           | 2023-12-01        |
| BINARLY public disclosure date         | 2024-06-19        |

## Acknowledgements

**BINARLY efiXplorer team**
