# [BRLY-2021-034]

# SMM memory corruption vulnerability in SMM driver on multiple HP devices.

## Summary

**BINARLY efiXplorer team** has discovered a SMM memory corruption vulnerability on multiple HP devices allowing a possible attacker to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-034
* HP PSIRT assigned CVE identifier: [CVE-2022-23926](https://support.hp.com/us-en/document/ish_5817864-5817896-16)
* CERT/CC assigned case number: VU#683814
* CVSS v3.1 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected HP firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| [Device](https://support.hp.com/us-en/drivers/selfservice/hp-prodesk-405-g6-small-form-factor-pc/38230306) / firmware version: `02.05.01 Rev.A` | 015D | 1e522785a0a50a4888ea20a91188ed1b40aafdde504d6ee2bd78b389269b4269 | 29A7E278-1768-42F6-8856-2EB0E013BE67 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in the SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in the child SW SMI handler registered with GUID `a9878bec-41e6-45fe-8148-2f68c0f7f886` and located at offset `0x1690` in the driver.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler_1690(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        CommBufferStruct *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( CommBuffer && CommBufferSize && (-(*CommBufferSize != 32) & EFI_INVALID_PARAMETER) == 0 )
  {
    Status = EFI_UNSUPPORTED;
    if ( !gComparePointersRes )
    {
      if ( gSmst )
        Status = -(CommBuffer->Case != 0) & EFI_UNSUPPORTED;
      goto _Exit;
    }
    Case = CommBuffer->Case;
    if ( Case )
    {
      Case1 = (Case - 1);
      if ( Case1 )
      {
        Case2 = Case1 - 1;
        if ( !Case2 )
        {
          Status = EFI_NOT_FOUND;
          if ( gFlag )
          {
            CommBuffer->Flag = gFlag;
            Status = 0;
          }
          goto _Exit;
        }
        Case3 = (Case2 - 1);
        if ( Case3 )
        {
          Case4 = (Case3 - 1);
          if ( Case4 )
          {
            if ( Case4 == 1 )
            {
              if ( gSrcBuffer && MEMORY[0xFED40F00] == 0x1050 )
              {
                NewSize = gSrcBuffer;
                DstSize = CommBuffer->DstSize;
                SrcBufferSize = *gSrcBuffer;
                if ( DstSize < SrcBufferSize )
                {
                  Status = EFI_BUFFER_TOO_SMALL;
                }
                else
                {
                  Dst = CommBuffer->Dst;
                  if ( Dst )
                  {
                    CopyMemS(Dst, DstSize, gSrcBuffer + 2, SrcBufferSize);
                    NewSize = gSrcBuffer;
                  }
                  Status = 0;
                }
                CommBuffer->DstSize = *NewSize;
              }
              ...
            }
            ...
          }
          ...
        }
        ...
      }
      ...
    }
    ...
  }
  return 0;
}
```

Let's assume that the CommBuffer has the following structure:

```
00000000 CommBufferStruct struc ; (sizeof=0x20, mappedto_234)
00000000 Case            dd ?
00000004 Flag            dd ?
00000008 Status          dq ?
00000010 DstSize         dq ?
00000018 Dst             dq ?
00000020 CommBufferStruct ends
```

If we set `CommBuffer->Case` to `0x05` than we can trigger the following code (if `MEMORY[0xFED40F00] != 0x1050`):

```c++
Dst = CommBuffer->Dst;
if ( Dst )
{
  CopyMemS(Dst, DstSize, gSrcBuffer + 2, SrcBufferSize);
  NewSize = gSrcBuffer;
}
Status = 0i64;
```

The nested pointer `CommBuffer->Dst` is not validated and a potential attacker could use this to overwrite the contents of SMRAM.

To exploit this vulnerability it is enough to:

1. Setup Communication Buffer:
  * `CommBuffer->Case = 5`
  * `CommBuffer->Dst = {address from SMRAM}`
2. Trigger the SW SMI Handler (SW SMI number and pointer to Communication Buffer are specified in UEFI ACPI table) via `0xB2` IO port

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| HP PSIRT is notified                     | 2021-07-12    |
| HP PSIRT confirmed reported issue        | 2021-08-09    |
| HP PSIRT assigned CVE number             | 2021-08-19    |
| CERT/CC created a case                   | 2021-11-16    |
| HP PSIRT provide patch release           | 2022-03-08    |
| BINARLY public disclosure date           | 2022-03-08    |

## Acknowledgements

**BINARLY efiXplorer team**
