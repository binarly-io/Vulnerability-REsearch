# [BRLY-2021-043]

# SMM arbitrary code execution in USBRT SMM driver on Dell devices.

## Summary

**BINARLY efiXplorer team** has discovered SMM arbitrary code execution on Dell devices.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-043
* CERT/CC assigned case number: VU#540990
* Dell PSIRT assigned CVE identifier: CVE-2022-24420
* CVSS v3.1 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| DELL Inspiron 15 Gaming 7567 | USBRT | 05011cd7c3b27b2e723ed88f7c4d0512ed1045c5265897aefba73fd6b8e7fece | 04EAAAA1-29A1-11D7-8838-00500473D4EB |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in SW SMI handler located at offset `0x1BC8` in the driver.
The handler is registered as follows:

```c++
result = (gSmst->SmmLocateProtocol)(&EFI_SMM_SW_DISPATCH2_PROTOCOL_GUID, 0, &EfiSmmSwDispatch2Protocol);
if ( result >= 0 )
{
  RegisterContext.SwSmiInputValue = 0x31;
  EfiSmmSwDispatch2Protocol->Register(EfiSmmSwDispatch2Protocol, SmiHandler, &RegisterContext, &DispatchHandle);
  ...
}
```

The pseudocode of the vulnerable handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  UsbData = gUsbData;
  Struct = *(gUsbData + 25824);
  if ( Struct )
  {
    *(gUsbData + 25824) = 0;
  }
  else
  {
    if ( (*(gUsbData + 8) & 0x10) != 0 )
      return 0;
    Struct = *(16 * MEMORY[0x40E] + 260);
    // check that the buffer does not overlap with SMRAM
    if ( BufferValidation(Struct, 47) < EFI_SUCCESS )
      return 0;
    *(UsbData + 26904) = 1;
  }
  if ( !Struct )
    return 0;
  FuncIndex = *Struct;
  if ( !*Struct )
    goto _Exec;
  if ( FuncIndex >= 32 && FuncIndex <= 56 )
  {
    FuncIndex -= 31;
_Exec:
    (gUsbApiTable[FuncIndex])(Struct);
    UsbData = gUsbData;
  }
  if ( !*(UsbData + 25824) )
    *(UsbData + 26904) = 0;
  return 0;
}
```

`Struct` value can be controlled by attacker with Ring 0 privileges.
If `FuncIndex == 14`, than the function located at offset `0x3080` will be called:

```c++
__int64 __fastcall UsbApiHcProc(STRUCT *Struc)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  result = Invoke(
             *(192 * ((Struc->HcType - 16) >> 4) + gUsbData + 112 + 8 * Struc->SubfuncIndex + 8),
             Struc->ParamBuffer,
             (Struc->ParamSize + 3) & ~3u);
  Struc->RetVal = 0;
  Struc->ApiRetVal = result;
  return result;
}
```

The first argument to the `Invoke` function is a pointer to be retrieved from the structure pointed to by `gUsbData`.
The pseudocode of the `Invoke` function is shown below:

```c++
__int64 __fastcall Invoke(__int64 (*Ptr)(void), _QWORD *ParamBuffer, unsigned int ParamSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v3 = ParamSize >> 3;
  if ( !v3 )
    return Ptr();
  v4 = v3 - 1;
  if ( !v4 )
    return (Ptr)(*ParamBuffer);
  v5 = v4 - 1;
  if ( !v5 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1]);
  v6 = v5 - 1;
  if ( !v6 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2]);
  v7 = v6 - 1;
  if ( !v7 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2], ParamBuffer[3]);
  v8 = v7 - 1;
  if ( !v8 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2], ParamBuffer[3], ParamBuffer[4]);
  v9 = v8 - 1;
  if ( !v9 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2], ParamBuffer[3], ParamBuffer[4], ParamBuffer[5]);
  if ( v9 == 1 )
    return (Ptr)(
             *ParamBuffer,
             ParamBuffer[1],
             ParamBuffer[2],
             ParamBuffer[3],
             ParamBuffer[4],
             ParamBuffer[5],
             ParamBuffer[6]);
  return 0;
}
```

According to this pseudocode, if an attacker can control a pointer, then he can execute an arbitrary function and pass up to 7 parameters to it.

`gUsbData` structure initialized in `UHCD` DXE driver (GUID: `580DD900-385D-11D7-883A-00500473D4EB`).
The pseudocode of the function used for initialization shown below:

```c++
void *__cdecl AllocatePoolWithAlign(UINTN AllocationSize, UINTN Align)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Align_1 = Align;
  Size = AllocationSize;
  Memory = 0xFFFFFFFF;
  gFlag = 0;
  if ( (gBS_0->AllocatePages(AllocateMaxAddress, EfiRuntimeServicesData, 0x10, &Memory) & 0x8000000000000000) != 0
    && (gBS_0->AllocatePages(AllocateAnyPages, EfiRuntimeServicesData, 0x10, &Memory) & 0x8000000000000000) != 0 )
  {
    return 0;
  }
  gMem = Memory;
  gBS_0->SetMem(Memory, 0x10000, 0);
  qword_BF98 = 0;
  qword_BFA8 = 0xFFFF;
  v5 = 0 % Align_1;
  if ( v5 )
    v6 = Align_1 - v5;
  else
    v6 = 0;
  gMem = v6 + Size;
  return (v6 & -(v6 + Size < 0xFFFF));
}
```

This means that an attacker with Ring 0 privileges will be able to find this buffer in system memory and modify it to execute arbitrary code.

To fix this problem, you need to check the pointer passed to the `Invoke` function (for example, call a function from a global table after checking the index).

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Dell PSIRT is notified                   | 2021-12-08    |
| Dell PSIRT confirmed reported issue      | 2022-02-25    |
| Dell PSIRT assigned CVE number           | 2022-02-25    |
| Dell PSIRT provide patch release         | 2022-02-25    |
| BINARLY public disclosure date           | 2022-03-10    |

## Acknowledgements

**BINARLY efiXplorer team**
