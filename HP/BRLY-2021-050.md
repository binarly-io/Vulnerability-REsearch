# [BRLY-2021-050]

*Reported as a part of [Intel Camping with Tigers bug bounty program](https://www.projectcircuitbreaker.com/camping-with-tigers)*

# SMM memory corruption vulnerability in SMM driver on Intel platforms.

## Summary

**BINARLY efiXplorer team** has discovered SMM memory corruption vulnerability on Intel platforms allowing a possible attacker to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-050
* Intel PSIRT assigned CVE identifier: [CVE-2022-23954](https://support.hp.com/us-en/document/ish_5661066-5661090-16)
* CVSS v3.1: 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmwares with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| HP EliteBook x360 1040 G8 | 0168 | 15f4ec9a79a74a66b66ddd727aaee975ae04a84a8474dfc056580ea8b618acc7 | 35D58AB4-5F87-4827-8CEE-380D83E98680 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an evironment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in child SW SMI handler registered with GUID `24249387-8cbf-437c-9a21-d6410a42d7f2` and located at offset `0x18B8` in the binary.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( CommBuffer && CommBufferSize )
  {
    Res = *(_DWORD *)CommBuffer < 8;
    Value = *((_BYTE *)CommBuffer + 4);
    if ( !Res )
      goto _InvalidParameter;
    if ( *(_DWORD *)CommBuffer )
    {
      switch ( *(_DWORD *)CommBuffer )
      {
        case 1:
          goto _Case1;
        case 2:
          goto _Case2;
        case 3:
          goto _Case1;
        case 4:
          goto _Case2;
        case 5:
_Case1:
          Flag = 0;
_HpPolicy:
          status = HpPolicy(&Value, *(_DWORD *)CommBuffer, *((_QWORD *)CommBuffer + 2));
          if ( Flag && !status )
            *((_BYTE *)CommBuffer + 4) = Value;
          goto _Exit;
      }
      if ( *(_DWORD *)CommBuffer != 6 )
      {
        if ( *(_DWORD *)CommBuffer == 7 )
          goto _Case1;
_InvalidParameter:
        status = EFI_INVALID_PARAMETER;
_Exit:
        *((_QWORD *)CommBuffer + 1) = status;
        return 0;
      }
    }
_Case2:
    Flag = 1;
    goto _HpPolicy;
  }
  return 0;
}
```

Before SMI handler will be triggered, CommBuffer will be checked for overlap with SMRAM (inside `PiSmmCommunicationSmm` module):

```c++
EFI_STATUS __fastcall SwSmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Status = 0;
  CommunicationHeader = *gCommunicationHeader;
  if ( *gCommunicationHeader )
  {
    if ( SmmIsBufferOutsideSmmValid(*gCommunicationHeader, 24) )
    {
      CommBufferSizea[0] = CommunicationHeader->MessageLength;
      if ( SmmIsBufferOutsideSmmValid(CommunicationHeader->Data, CommBufferSizea[0]) )
        Status = gSmst->SmiManage(
                   &CommunicationHeader->HeaderGuid,
                   0,
                   CommunicationHeader->Data,
                   CommBufferSizea);
    }
  }
  return -(Status != 0) & 0xA000000000000000;
}
```

If `CommunicationHeader->MessageLength` is `0` and `CommunicationHeader->Data` does not overlap with SMRAM, check will pass.

As we can see from the pseudocode, `*CommBufferSize` is not checked (only the `CommBufferSize` pointer is compared to NULL). But at the same time there is a primitive for writing 8 fixed bytes at the address CommBuffer + 8:

```c++
*((_QWORD *)CommBuffer + 1) = status;
return 0;
```

This leads to rewriting pointed area with a predictable data - Status code.
Writing such data into SMRAM could allow a possible attacker to corrupt some structures in the beginning of this memory (for example, change SMM S3 resume code pointer and hijack execution flow during SMM S3 wake up procedure).
This could lead to gaining arbitrary code execution in SMM.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Intel PSIRT is notified                  | 2022-01-05    |
| HP PSIRT provide patch release           | 2022-03-15    |
| BINARLY public disclosure date           | 2022-05-23    |

## Acknowledgements

**BINARLY efiXplorer team**
