# [BRLY-2022-022]
# SMM callout vulnerability in SMM driver (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified a SMM callout, which allows an attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2022-022
* Insyde PSIRT assigned CVE identifier: CVE-2022-35408
* FwHunt rule: [BRLY-2022-022](https://github.com/binarly-io/FwHunt/blob/main/rules/Vulnerabilities/Insyde/BRLY-2022-022.yml)
* CVSS v3.1 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Insyde firmware with confirmed impact by Binarly team

| Fimware | Module name | Module SHA256 | File GUID |
| --- | --- | --- | --- |
| Framework_Laptop_12th_Gen_Intel_Core_capsule_EFI_signed_allsku_3.01.bin | UsbLegacyControlSmm | bba9150c7c87cade14ec29def8d8c320b64e65c718e60c5aa0278c1239cd45f0 | 88ea1fcb-3a5d-4acf-a0b3-aacb36d4e90f |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an evironment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

Vulnerability exists in the USB System Management Interrupt (USBSMI) handler located at offset `0x13F4` in the module `UsbLegacyControlSmm.efi`.

The handler is registered as shown below:

```c++
RegisterContext.Type = UsbLegacy;
RegisterContext.Device = &gDevicePath;
if ( (EfiSmmUsbDispatch2Protocol->Register(EfiSmmUsbDispatch2Protocol, UsbSmiHandler, &RegisterContext, &Handle) & 0x8000000000000000) != 0 ) return EFI_UNSUPPORTED;
```

The pseudocode of USB SMI handler is shown below:

```c++
__int64 __fastcall UsbSmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS]

  result = 0;
  if ( (MEMORY[0xC00F8094] & 0xF00) != 0 )
    result = (MEMORY[0xC00F8094] >> 8) & 0xF;
  v5 = UsbLegacyProtocolFunc1;
  if ( UsbLegacyProtocolFunc1 )
    result = UsbLegacyProtocolFunc1(result, UsbLegacyProtocolFunc2);
  if ( !gNotTheFirstTime )
  {
    OldTpl = (gBS->RaiseTPL)(31);
    (gBS->RestoreTPL)(OldTpl);
    if ( OldTpl == 31 )
      (gBS->RestoreTPL)(8);
    gNotTheFirstTime = 1;
    if ( (gBS->LocateHandleBuffer(ByProtocol, &ProprietaryProtocol, 0, &NoHandles, &Buffer) & 0x8000000000000000u) == 0 )
    {
      v7 = 0;
      if ( NoHandles )
      {
        while ( (gBS->HandleProtocol(Buffer[v7], &ProprietaryProtocol, &Interface) & 0x8000000000000000u) != 0
             || *(Interface + 24) )
        {
          if ( ++v7 >= NoHandles )
            goto _Exit;
        }
        UsbLegacyProtocolFunc1 = *(Interface + 1);
        UsbLegacyProtocolFunc2 = *(Interface + 2);
      }
    }
_Exit:
    result = gBS->FreePool(Buffer);
    if ( OldTpl == 31 )
      return (gBS->RaiseTPL)(31);
  }
  return result;
}
```

From the pseudocode, we can see that the handler uses services from `EFI_BOOT_SERVICES` table (if the handler works for the first time according to the `gNotTheFirstTime` flag).

Thus, a potential attacker could overwrite the functions pointers in the `EFI_BOOT_SERVICES` table before the USB SMI handler triggered, which would lead to arbitrary code execution in the SMM.

The vulnerability cannot be exploited from the operating system. However, using `EFI_BOOT_SERVICES` and `EFI_RUNTIME_SERVICES` is unsafe inside a code intended to run in SMM (from SMRAM) because an attacker capable of executing code in DXE phase could exploit this vulnerability to escalate privileges to SMM (ring -2).
This can be achieved even after `EfiSmmReadyToLock` event since no `gSmst->InSmram()` check is applied.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Framework PSIRT is notified              | 2022-06-27    |
| Insyde PSIRT confirmed reported issue    | 2022-07-19    |
| Insyde PSIRT assigned CVE number         | 2022-07-25    |
| BINARLY public disclosure date           | 2022-09-21    |

## Acknowledgements

**BINARLY efiXplorer team**
