# [BRLY-2021-045]

# SMM callout vulnerability in USBRT SMM driver on Dell devices (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified SMM callout on Dell platforms, which allows a attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-045
* CERT/CC assigned case number: VU#540990
* Dell PSIRT assigned CVE identifier: CVE-2022-24421
* CVSS v3.1 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| DELL Inspiron 15 Gaming 7567 | USBRT | 05011cd7c3b27b2e723ed88f7c4d0512ed1045c5265897aefba73fd6b8e7fece | 04EAAAA1-29A1-11D7-8838-00500473D4EB |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in SW SMI handler located at offset `0x1BC8` in the driver.
The handler is registered as follows:

```c++
result = (gSmst->SmmLocateProtocol)(&EFI_SMM_SW_DISPATCH2_PROTOCOL_GUID, 0, &EfiSmmSwDispatch2Protocol);
if ( result >= 0 )
{
  RegisterContext.SwSmiInputValue = 0x31;
  EfiSmmSwDispatch2Protocol->Register(EfiSmmSwDispatch2Protocol, SmiHandler, &RegisterContext, &DispatchHandle);
  ...
}
```

The pseudocode of the vulnerable handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  UsbData = gUsbData;
  Struct = *(gUsbData + 25824);
  if ( Struct )
  {
    *(gUsbData + 25824) = 0;
  }
  else
  {
    if ( (*(gUsbData + 8) & 0x10) != 0 )
      return 0;
    Struct = *(16 * MEMORY[0x40E] + 260);
    // check that the buffer does not overlap with SMRAM
    if ( BufferValidation(Struct, 47) < EFI_SUCCESS )
      return 0;
    *(UsbData + 26904) = 1;
  }
  if ( !Struct )
    return 0;
  FuncIndex = *Struct;
  if ( !*Struct )
    goto _Exec;
  if ( FuncIndex >= 32 && FuncIndex <= 56 )
  {
    FuncIndex -= 31;
_Exec:
    (gUsbApiTable[FuncIndex])(Struct);
    UsbData = gUsbData;
  }
  if ( !*(UsbData + 25824) )
    *(UsbData + 26904) = 0;
  return 0;
}
```

`Struct` value can be controlled by attacker with Ring 0 privileges.
If `FuncIndex == 15`, than the function located at offset `0x30D8` will be called:

```c++
__int64 __fastcall UsbApiCoreProc(STRUCT *Struct)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  result = Invoke(gCoreProcTable[Struct->SubfuncIndex], Struct->ParamBuffer, (Struct->ParamSizeCoreProc + 3) & ~3u);// No index validation
  Struct->RetVal = 0;
  *&Struct->ApiRetValCoreProc = result;
  return result;
}
```

The first argument to the `Invoke` function is a pointer to be retrieved from the structure pointed to by `gUsbData`.
The pseudocode of the `Invoke` function is shown below:

```c++
__int64 __fastcall Invoke(__int64 (*Ptr)(void), _QWORD *ParamBuffer, unsigned int ParamSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v3 = ParamSize >> 3;
  if ( !v3 )
    return Ptr();
  v4 = v3 - 1;
  if ( !v4 )
    return (Ptr)(*ParamBuffer);
  v5 = v4 - 1;
  if ( !v5 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1]);
  v6 = v5 - 1;
  if ( !v6 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2]);
  v7 = v6 - 1;
  if ( !v7 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2], ParamBuffer[3]);
  v8 = v7 - 1;
  if ( !v8 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2], ParamBuffer[3], ParamBuffer[4]);
  v9 = v8 - 1;
  if ( !v9 )
    return (Ptr)(*ParamBuffer, ParamBuffer[1], ParamBuffer[2], ParamBuffer[3], ParamBuffer[4], ParamBuffer[5]);
  if ( v9 == 1 )
    return (Ptr)(
             *ParamBuffer,
             ParamBuffer[1],
             ParamBuffer[2],
             ParamBuffer[3],
             ParamBuffer[4],
             ParamBuffer[5],
             ParamBuffer[6]);
  return 0;
}
```

According to this pseudocode, if an attacker can control a pointer, then he can execute an arbitrary function and pass up to 7 parameters to it.

Let's see what gCoreProcTable looks like:

```
.text:0000000080000FC0 gCoreProcTable  dq offset Proc0         ; DATA XREF: UsbApiCoreProc+15↓o
.text:0000000080000FC8                 dq offset Proc1
.text:0000000080000FD0                 dq offset Proc2
.text:0000000080000FD8                 dq offset Proc3
.text:0000000080000FE0                 dq offset Proc4
.text:0000000080000FE8                 dq offset Proc5
.text:0000000080000FF0                 dq offset Proc6
.text:0000000080000FF8 ; EFI_GUID EFI_SMM_RUNTIME_SERVICES_TABLE_GUID
.text:0000000080000FF8 EFI_SMM_RUNTIME_SERVICES_TABLE_GUID dq 413E287F395C33FEh
.text:0000000080000FF8                                         ; DATA XREF: sub_80001664+78↓o
.text:0000000080000FF8                                         ; sub_8000191C+88↓o ...
.text:0000000080001000                 dq 3ED4E1C0888055A0h
.text:0000000080001008                 dq 0
.text:0000000080001010                 dq 0
.text:0000000080001018                 dq 0
```

`Struct->SubfuncIndex` is controlled by an attacker and can take values from 0 to 255.
The expected size of the `gCoreProcTable` array is 7, so it should check that `Struct->SubfuncIndex < 7` before calling `Invoke` function.

Since there is no check for `Struct->SubfuncIndex` value, if the value of `Struct->SubfuncIndex` equal 9 or 10 or 11, it which can lead to arbitrary code execution, since `gCoreProcTable[9] = gCoreProcTable[10] = gCoreProcTable[11] = 0`.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Dell PSIRT is notified                   | 2021-12-08    |
| Dell PSIRT confirmed reported issue      | 2022-02-25    |
| Dell PSIRT assigned CVE number           | 2022-02-25    |
| Dell PSIRT provide patch release         | 2022-02-25    |
| BINARLY public disclosure date           | 2022-03-10    |

## Acknowledgements

**BINARLY efiXplorer team**
