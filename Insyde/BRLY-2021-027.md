# [BRLY-2021-027]

# SMM memory corruption vulnerability in combined DXE/SMM driver on BullSequana Edge server.

## Summary

**BINARLY efiXplorer team** has discovered a SMM memory corruption vulnerability on a BullSequana Edge server allowing a possible attacker to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulanerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-027
* CERT/CC assigned case number: [VU#796611](https://kb.cert.org/vuls/id/796611)
* Insyde PSIRT assigned CVE identifier: [CVE-2021-42554](https://www.insyde.com/security-pledge/SA-2022012)
* CVSS v3.1: 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected BullSequana Edge server firmware with confirmed impact by BINARLY team

| Package | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| [BIOS_SKD080.18.02.003.sign.tar.gz](https://support.bull.com/ols/product/platforms/bullion/bullsequana-edge-servers/dl/pkgf/g/firmware-of-technical-state-016.02/bios-skd080-rev-80-18-02-build-003/view) | FvbServicesRuntimeDxe | 86F43D9A386A07920A8D60AECD1AE3C58EB886EB5F2C9A9D1153156E34C965D4 | BDFE5FAA-2A35-44BB-B17A-8084D4E2B9E9 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerabilities description

The vulnerability exists in the SW SMI handler registered with number `0x16` and located at offset `0x3DBC` in the driver:

```C++
EFI_STATUS SwSmiHandler(EFI_HANDLE DispatchHandle, const void *Context, void *CommBuffer, UINTN *CommBufferSize)
{
    ...

    input = ReadSaveSate(EFI_SMM_SAVE_STATE_REGISTER_RAX);
    counter = 0;
    if ( gFuncsArray[0] )
    {
        offset = 0;
        while ( BYTE1(input) != (__int64)SLODWORD(gIndexArray[offset]) )
        {
            offset = 2 * ++counter;
            if ( !gIndexArray[2 * counter + 1] )
                goto LABEL_12;
        }
        v7 = gFuncsArray[2 * counter])(2 * counter, offset * 8, 0x8000000000000003);

...
```

As we can see, the input for this SW SMI handler is passed using CPU Save State. The contents of `RAX` register allows a handler's caller to choose the function for invoking from an array `gFuncsArray`:

```code
.data:00000000800113E8 gFuncsArray     dq offset Func0
.data:00000000800113F0                 dq 1
.data:00000000800113F8                 dq offset Func1
.data:0000000080011400                 dq 2
.data:0000000080011408                 dq offset Func2
```

Let's look at `Func0()` for example located at `0x3848` in the driver:

```C++
__int64 Func0()
{
    v0 = ReadSaveSate(EFI_SMM_SAVE_STATE_REGISTER_RBX);
    ptr = ReadSaveSate(EFI_SMM_SAVE_STATE_REGISTER_RSI);
    LOBYTE(v2) = 1;
    
    if ( v0 != sub_80009F6C((__int64)&stru_80011078, v2) + 40 || *(_DWORD *)(ptr + 8) != 'AFMS' )
        return 0x8000000000000003ui64;
    
    result = (*(_QWORD *)(gSmmBuffer + 8) + 8))(*(_QWORD *)(gSmmBuffer + 8), *(_QWORD *)(ptr + 0x10), 0, ptr + 0x20, ptr + 0x28);
    
    *(_QWORD *)ptr = result;
    
    return result;
}
```

Here an additional input is extracted from saved `RSI` register - a pointer, which is not validated to point outside of SMRAM. Only a simple signature (`SMFA`) comparison is applied, but this is insufficient, because a possible attacker can make this pointer to point directly to this signature in this code or any other suitable location in SMRAM to bypass this check.

This leads to rewriting pointed area with a fixed or predictable data - return's `result`. Writing such data into SMRAM could allow a possible attacker to modify SMM code or to corrupt some data in SMRAM. This could lead to gaining arbitrary code execution in SMM.

To exploit this vulnerability it is enough to:

1. Make `RSI` register to point a desired location in SMRAM to modify (`*(_DWORD *)(ptr_1 + 8)` should point to `SMFA` signature.
2. Trigger the SW SMI handler `0x16` via `0xB2` IO port and providing the function index `0` in `RAX` register.

To fix this vulnerability, it is essential that all the input pointers (including the nested pointers) for SMI handlers are wrapped with sanity checks to make sure they are not pointing into SMRAM.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                   | Date           |
| ------------------------------------- | -------------- |
| CERT/CC created a case                | 2021-09-27     |
| Insyde PSIRT confirmed issue          | 2021-09-29     |
| Insyde PSIRT assigned CVE number      | 2021-10-18     |
| Insyde PSIRT provide patch release    | 2021-11-09     |
| BINARLY public disclosure date        | 2022-02-01     |

## Acknowledgements

**BINARLY efiXplorer team**
