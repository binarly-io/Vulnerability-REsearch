# [BRLY-2021-019]

# SMM callout vulnerability in combined DXE/SMM on Fujitsu device (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified a SMM callout in a Fujitsu device, which allows an attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-019
* CERT/CC assigned case number: [VU#796611](https://kb.cert.org/vuls/id/796611)
* Insyde PSIRT assigned CVE identifier: [CVE-2021-41840](https://www.insyde.com/security-pledge/SA-2022018) 
* CVSS v3.1: 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Fujitsu firmware with confirmed impact by BINARLY team

| Device name | Driver name | Driver SHA256 | File GUID |
| --- | --- | --- | --- |
| Fujitsu LIFEBOOK E459/E449 | SdHostDriver | a6f1c365d80a77c85964a4dd477e4986e20d296ae8744c7ef33931e24cfcbb3f | 67BBC344-84BC-4E5C-B4DF-F5E4A00E1F3A |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability could potentially be used by threat actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

In the function at offset `0xB94` (image sha256: `a6f1c365d80a77c85964a4dd477e4986e20d296ae8744c7ef33931e24cfcbb3f`), the child software System Management Interrupt (SWSMI) handler with the GUID `3779ad93-b988-43bc-91f0-3b6c6e38fadb` is registered:

```c++
if ( v4 )
{
  result = gSmst_80003EB8->SmiHandlerRegister(SmiHandler_80000984, &gSmiHandlerGuid, &DispatchHandle);
  if ( result >= 0 )
  {
    Status = gSmst_80003EB8->SmmRegisterProtocolNotify(&Protocol, Function, v8);
    if ( Status < 0 )
      return Status;
    return v3;
  }
}
```

Find below the decompiled SWSMI handler code:

```c++
EFI_STATUS __fastcall SmiHandler_80000984(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  CommBuffer1 = CommBuffer;
  if ( CommBuffer && CommBufferSize )
  {
    if ( *CommBuffer )
    {
      Status = EFI_UNSUPPORTED;
    }
    else if ( *(CommBuffer + 2) == 0x130 )
    {
      CommBuffer1 = CommBuffer + 0x18;
      Status = sub_800007F8(0, CommBuffer + 0x18);
    }
    else
    {
      Status = EFI_INVALID_PARAMETER;
    }
    *(CommBuffer1 + 1) = Status;
  }
  return 0;
}
```

The `sub_800007F8` function contains the following code snippet:

```c++
if ( !gPMTimerBlock
  // SMM callout
  && (gBS_80003E80->LocateProtocol(&EFI_ACPI_SUPPORT_PROTOCOL_GUID_80003C60, 0, &EfiAcpiSupportProtocol) & 0x8000000000000000) == 0 )
{
  Index = 0;
  do
  {
    Status = (EfiAcpiSupportProtocol->GetAcpiTable)(EfiAcpiSupportProtocol, Index, &FacpBuffer, &v14, v13);
    if ( Status >= 0 )
    {
      if ( FacpBuffer->h.Signarure == 'PCAF' )
      {
        Status = EFI_ABORTED;
        gPMTimerBlock = FacpBuffer->PMTimerBlock;
      }
      gBS_80003E80->FreePool(FacpBuffer);
    }
    ++Index;
  }
  while ( !Status );
}
```

If the global variable `gPMTimerBlock` is set to `0`, the code uses two services from `EFI_BOOT_SERVICES`:  
* `LocateProtocol()`
* `FreePool()`

It should be noted that the `gPMTimerBlock` global variable value will be set after the first run of this SMI handler (in order to use it in functions that implement a timeout). Due to this fact this vulnerability cannot be exploited from the operating system. However, using `EFI_BOOT_SERVICES` and `EFI_RUNTIME_SERVICES` services is unsafe inside code intended to run in SMM (from SMRAM) because an attacker capable of executing code in DXE phase could exploit this vulnerability to escalate privileges to SMM (ring -2).

To exploit this vulnerability is enough to:

* overwrite the `LocateProtocol()` or `FreePool()` address in the `EFI_BOOT_SERVICES` table with the shellcode address
* trigger the SWSMI handler (SwSmi number is specified in UEFI ACPI table)

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Fujitsu PSIRT is notified                | 2021-09-10    |
| Fujitsu PSIRT is confirmed issue         | 2021-09-14    |
| CERT/CC created a case                   | 2021-09-27    |
| Insyde PSIRT assigned CVE number         | 2021-11-01    |
| Insyde PSIRT provide patch release       | 2021-11-09    |
| BINARLY public disclosure date           | 2022-02-01    |

## Acknowledgements

**BINARLY efiXplorer team**
