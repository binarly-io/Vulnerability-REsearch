# [BRLY-2021-047]

# SMM callout vulnerability in SMM driver on HP device (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified SMM callout on HP device, which allows a attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-047
* HP PSIRT assigned CVE identifier: [CVE-2022-31641](https://support.hp.com/us-en/document/ish_6662920-6662944-16/hpsbhf03805)
* CVSS v3.1: 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| HP EliteBook x360 1040 G8 | 0511 | 40f569059699b5de2e60eb5f618755163ef2b059adafb5ac35e18fdeb20edef6 | 0D966D65-8F25-4574-8EAF-6C0463F38742 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an evironment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in child SW SMI handler registered with GUID `807ca9f6-216c-4cbc-87f7-3cd555887208` and located at offset `0x17DC` in the binary.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( CommBuffer )
  {
    if ( CommBufferSize )
    {
      Length = *CommBufferSize;
      if ( (-(*CommBufferSize != 160) & EFI_INVALID_PARAMETER) == 0 )
      {
        Res = 0;
        if ( Length )
          Res = SmmIsBufferOutsideSmmValid(CommBuffer, Length);
        if ( (-(Res == 0) & EFI_INVALID_PARAMETER) == 0 )
        {
          Status = -(*CommBuffer != 'GFCU') & EFI_INVALID_PARAMETER;
          if ( *CommBuffer == 'GFCU' )
          {
            switch ( *(CommBuffer + 1) )
            {
              case 0x10:
                if ( !gBuffer )
                {
                  Buffer = GetCopy(0x78, CommBuffer + 24);
                  BufferSize = *(CommBuffer + 2);
                  BufferPtr = *(CommBuffer + 1);
                  gBuffer = Buffer;
                  sub_261C(BufferPtr, BufferSize);
                  PcdProtocol = LocatePcdProtocol();
                  if ( (PcdProtocol->Get8)(0x23B) == 1 )
                    FreeAndUnregister();
                }
                break;
              ...
              default:
_InvalidParameter:
                Status = EFI_INVALID_PARAMETER;
                break;
            }
          }
          *(CommBuffer + 19) = Status;
        }
      }
    }
  }
  return 0;
}
```

Consider the `case 0x10` branch:

If `gBuffer` is not NULL (since `gBuffer` is initialized only within this branch, it will always be NULL the first time it is run), the protocol interface `EFI_PCD_PROTOCOL` will be located (via `gBS->LocateProtocol` call) and the `Get8` function from the protocol will be called.

The pseudocode of the `LocatePcdProtocol` function is shown below:

```c++
PCD_PROTOCOL *LocatePcdProtocol()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  result = gPcdProtocol;
  if ( !gPcdProtocol )
  {
    gBS->LocateProtocol(&PCD_PROTOCOL_GUID, 0i64, &gPcdProtocol);
    return gPcdProtocol;
  }
  return result;
}
```

This means that a potential attacker could overwrite the `gBS->LocateProtocol` pointer in the `EFI_BOOT_SERVICES` table with the shellcode address and trigger this handler. As a result, it will execute arbitrary code in SMRAM.

If the `EFI_PCD_PROTOCOL` interface is already located (`gPcdProtocol` is not NULL), a potential attacker could overwrite not the `gBS->LocateProtocol` pointer, but the `gPcdProtocol->SetBool` pointer.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| HP PSIRT is notified                     | 2021-07-12    |
| HP PSIRT confirmed reported issue        | 2021-08-09    |
| HP PSIRT assigned CVE number             | 2021-08-19    |
| CERT/CC created a case                   | 2021-11-16    |
| HP PSIRT provide patch release           | 2022-03-08    |
| BINARLY public disclosure date           | 2022-03-08    |

## Acknowledgements

**BINARLY efiXplorer team**
