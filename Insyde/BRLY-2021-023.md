# [BRLY-2021-023]

# SMM callout vulnerability in combined DXE/SMM driver on BullSequana Edge server.

## Summary

**BINARLY efiXplorer team** has discovered a SMM callout vulnerability on a BullSequana Edge server allowing a possible attacker to hijack the execution flow of a code running in System Management Mode. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-023
* CERT/CC assigned case number: [VU#796611](https://kb.cert.org/vuls/id/796611)
* Insyde PSIRT assigned CVE identifier: [CVE-2021-42113](https://www.insyde.com/security-pledge/SA-2022008)
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected BullSequana Edge server firmware with confirmed impact by BINARLY team

| Package | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| [BIOS_SKD080.18.02.003.sign.tar.gz](https://support.bull.com/ols/product/platforms/bullion/bullsequana-edge-servers/dl/pkgf/g/firmware-of-technical-state-016.02/bios-skd080-rev-80-18-02-build-003/view) | StorageSecurityCommandDxe | A41A4C78197F7C1CE62A4C94E9EEB1119A1005E9F049CD086C2F8B52D7406394 | 70D57D67-7F05-494D-A014-B75D7345B700 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability could potentially be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerabilities description

The vulnerability exists in the child SW SMI handler registered with the GUID `1d3de7f0-0807-424f-aa69-11a54e19a46f` and located at offset `0x1E0C` in the driver:

```C++
EFI_STATUS SmiHandler(EFI_HANDLE DispatchHandle, const void *Context, void *CommBuffer, UINTN *CommBufferSize)
{
    if ( CommBuffer && CommBufferSize )
    {
        if ( *(_QWORD *)CommBuffer == 1 )
        {
            LOBYTE(Context) = 1;
            Status = sub_80001508(*((_QWORD *)CommBuffer + 2), (char)Context);
            ...
        }
...
```

As we can see in case `1` is passed as the first `QWORD` inside a Communication Buffer the `sub_80001508()` function is called. The second argument of this routine indicates whether the function is executed in SMM (from SMRAM) or not, thus the routine contains the following constructions:

```C++
EFI_STATUS sub_80001508(__int64 Pointer, char InSmm)
{
    if ( InSmm )
    {
        // usage of gSmst
        ...
    }
    else
    {
        // usage of gBS
        ...
    }
}
```

Still, at least one `EFI_BOOT_SERVICES` dereferencing operation is left without any dependency to `InSmm` flag:

```C++
...

Status = InSmm
    ?
    gSmst->SmmHandleProtocol(v15, &EFI_ATA_PASS_THRU_PROTOCOL_GUID, (void **)&EfiAtaPassThruProtocol)
    :
    gEfiBootServices->HandleProtocol(v15, &EFI_ATA_PASS_THRU_PROTOCOL_GUID, (void **)&EfiAtaPassThruProtocol);
				
if ( !Status )
{
    if ( EfiAtaPassThruProtocol )
    {
        Status = gEfiBootServices->LocateHandleBuffer(ByProtocol, &EFI_DISK_INFO_PROTOCOL_GUID, 0, &v46, &v38);
        
...
```

This vulnerable operation is possible in SMM in case `gSmst->SmmHandleProtocol()` returns `EFI_SUCCESS` and `EfiAtaPassThruProtocol` will be initialized by this call.

Let's go back to the beginning of the SMI handler. In case `2` is passed as the first `QWORD` inside a Communication Buffer the following code is executed in a loop:

```C++
EFI_STATUS SmiHandler(EFI_HANDLE DispatchHandle, const void *Context, void *CommBuffer, UINTN *CommBufferSize)
{
    if ( CommBuffer && CommBufferSize )
    {
        if ( *(_QWORD *)CommBuffer == 2 )
        {
            ...
        }
        if ( *(_QWORD *)CommBuffer == 2 )
        {
            ...
		        
            while ( 1 )
            {
                Status = gSmst->SmmHandleProtocol)(*(_QWORD *)(v8 + 8 * v6), &EFI_STORAGE_SECURITY_COMMAND_PROTOCOL_GUID, &EfiStorageSecurityCommandProtocol);
                if ( !Status )
                {
                    if ( *(_QWORD *)(EfiStorageSecurityCommandProtocol - 0x20) == 'GOTS' && !*(_QWORD *)(EfiStorageSecurityCommandProtocol - 8) )
                    {
                        for ( i = 0; i < v17; v10 = i )
                        {
                            if ( !gEfiBootServices->HandleProtocol)(*(_QWORD *)(v16 + 8 * v10), &EFI_STORAGE_SECURITY_COMMAND_PROTOCOL_GUID, &v19)

...
```

Here is a similar situation: in case `gSmst->SmmHandleProtocol()` returns `EFI_SUCCESS` and valid pointer `EfiStorageSecurityCommandProtocol`, the `EFI_BOOT_SERVICES` dereferencing operation has occurred.

Usage of `EFI_BOOT_SERVICES` and `EFI_RUNTIME_SERVICES` is unsafe inside a code intended to run in SMM (from SMRAM), especially in SMI handlers, because a possible attacker with a R/W access to system memory could hook pointers in these tables to escalate privileges to SMM (ring -2).

To exploit this vulnerability it is enough to:

1. Find `EFI_BOOT_SERVICES` table in system memory.
2. Overwrite `LocateHandleBuffer()` or `HandleProtocol()` service pointer in it with the shellcode address.
3. Set up the first `QWORD` of a Communication Buffer with a value of either `1` or `2`.
4. Trigger the SW SMI Handler (SW SMI number and pointer to Communication Buffer are specified in UEFI ACPI table) via `0xB2` IO port.

To fix this vulnerability, it is essential that the usage of `EFI_BOOT_SERVICES` is minimised only to SMM driver's early initialization routine.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                   | Date           |
| ------------------------------------- | -------------- |
| CERT/CC created a case                | 2021-09-27     |
| Insyde PSIRT confirmed issue          | 2021-09-29     |
| Insyde PSIRT assigned CVE number      | 2021-11-03     |
| Insyde PSIRT provide patch release    | 2021-11-09     |
| BINARLY public disclosure date        | 2022-02-01     |

## Acknowledgements

**BINARLY efiXplorer team**
