# [BRLY-2021-009]

# SMM memory corruption vulnerability in combined DXE/SMM driver on Fujitsu device (SMRAM write).

## Summary

**BINARLY efiXplorer team** has discovered a SMM memory corruption vulnerability in a Fujitsu device allowing a possible attacker to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-009
* CERT/CC assigned case number: VU#796611
* Insyde PSIRT assigned CVE identifier: CVE-2021-41837
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Fujitsu firmwares with confirmed impact by BINARLY team

| Device name | Driver name | Driver SHA256 | File GUID |
| --- | --- | --- | --- |
| Fujitsu LIFEBOOK A3510 | AhciBusDxe | 4CD998206D448CA937B666D1CF8B398ECCF8A985DA0FC02FFB49A46F0D5A9AB5 | 3ACC966D-8E33-45C6-B4FE-62724BCD15A9 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

First, let's look at the routine located at offset `0x1DD4` in the `AhciBusDxe` driver. Its DXE branch (code intended to be executed during DXE phase) allocates several buffers in the system memory:

```C++
if ( IsSmstFound() )
{
    // SMM branch
    ...
}
else
{
    // DXE branch
    result = gEfiBootServices->AllocatePool(EfiReservedMemoryType, 0x250, &gBuffer);
    if ( result >= 0 )
    {
        ZeroMemory((char *)gBuffer, 0x250);
        *(_QWORD *)gBuffer = 'ICHA';

        sub_8000B934((_QWORD *)gBuffer + 1);
        result = gEfiBootServices->AllocatePool(EfiReservedMemoryType, 0x190, &gBuffer2);
        if ( result >= 0 )
        {
            ZeroMemory((char *)gBuffer2, 0x190);
            *(_QWORD *)gBuffer2 = 'VEDA';

            ...

            ZeroMemory((char *)gBuffer2, 0x190);
            *(_QWORD *)gBuffer2 = 'VEDA';

            ...

            result = gEfiBootServices->AllocatePool(EfiReservedMemoryType, 0x44, &gBuffer3);
            if ( result >= 0 )
            {
                result = gEfiBootServices->AllocatePool(EfiReservedMemoryType, 0x184, &UnknownProtocol2);
                if ( result >= 0 )
                {
                  Handlea = 0i64;
                  *(_QWORD *)UnknownProtocol2 = gBuffer3;
                  *((_QWORD *)UnknownProtocol2 + 2) = gBuffer;
                  *((_QWORD *)UnknownProtocol2 + 1) = gBuffer2;

                  gEfiBootServices->InstallProtocolInterface(&Handlea, &UNKNOWN_PROTOCOL_2490595F_GUID, EFI_NATIVE_INTERFACE, UnknownProtocol2);

                  ...
}
```

The SMM branch (code intended to be executed in System Management Mode) of this function extracts the pointers to these buffers and registers a child software System Management Interrupt (SWSMI) handler with GUID `56947330-585c-4470-a95d-c55c529feb47`, which contains the actual vulnerability:

```C++
if ( IsSmstFound() )
{
    // SMM branch
    gEfiBootServices->LocateProtocol)(&UNKNOWN_PROTOCOL_2490595F_GUID, 0, &UnknownProtocol2);
    
    gBuffer3 = *UnknownProtocol2;
    gBuffer = *((_QWORD *)UnknownProtocol2 + 2);
    gBuffer2 = *((_QWORD *)UnknownProtocol2 + 1);

    v12 = 0i64;
    gEfiBootServices->InstallProtocolInterface(&v12, &UNKNOWN_PROTOCOL_36CBCA7D_GUID, EFI_NATIVE_INTERFACE, 0);

    result = gSmst->SmiHandlerRegister)(SmiHandler, &gSmiHandlerGuid, v17);
}
else
{
    // DXE branch
    ...
}
```

The SMI handler itself is located at offset `0x2DA4` in the driver:

```C++
EFI_STATUS SmiHandler(EFI_HANDLE DispatchHandle, const void *Context, void *CommBuffer, UINTN *CommBufferSize)
{
  if ( (char *)gBuffer3 + 0x18 == CommBuffer && *CommBufferSize == 0x2C && CommBuffer )
  {
    ...

    if ( *(_QWORD *)CommBuffer == 1 )
    {
      dword_800109F0 = *((_DWORD *)CommBuffer + 4);
      sub_8000318C();
    }

...
```

Obviously, an attacker can craft the Communication Buffer contents to enter the `sub_8000318C()` routine that starts with the following code:

```C++
for ( current_ptr = ReadQword(gBuffer + 8); !Compare(gBuffer + 8, current_ptr); current_ptr = ReadQword2(gBuffer + 8, current_ptr) )
  {
    if ( !*(_BYTE *)(current_ptr + 0x208) && *(_QWORD *)(current_ptr + 0x18) )
    {
      *(_BYTE *)(current_ptr + 0x208) = 1;
      
...
```

`ReadQword()` routine is used to dereference the input pointer.

As we can see, some `current_ptr` is set in a loop from a buffer pointed by `gBuffer`, and if the simple validation is successful a fixed byte value 1 will be written at offset `0x208` starting from place pointed by `current_ptr`. There is no pointer validation carried out (to ensure `current_ptr` and any other `gBuffer` nested contents are not pointing to SMRAM contents). In addition, there are many other operations performed on the memory pointed relatively by `current_ptr`.

Since this buffer is placed in system memory a possible attacker can find it and control its contents. Writing fixed data into SMRAM could allow a possible attacker to corrupt some data inside this memory (for example, change SMI handler's code or modify Smram Map structures to break input pointer validation for other SMI handlers, hence to completely make this mitigation inefficient). This could lead to gaining arbitrary code execution in SMM.

To exploit this vulnerability it is enough to:

1. Find buffers pointed by `gBuffer` and `gBuffer3` in system memory (with `AHCI` and `ADEV` signatures or by dumping & analyzing physical memory from exactly the same device model with exactly the same firmware version).
2. A pointer to a place to write in SMRAM should be specified at offset 8 inside `gBuffer`.
3. Communication buffer should be at `gBuffer3` + 0x18, so a pointer to it should be placed into UEFI ACPI table.
4. Call SW SMI (SwSmi number is specified in the UEFI ACPI table) via 0xB2 IO port, prior to it SMI handler GUID `56947330-585c-4470-a95d-c55c529feb47` and Communication Buffer size `0x2C` should be specified in Communication Buffer.

To fix this vulnerability, it is essential to wrap all the input pointers (including the nested pointers) of the SMI handlers with sanity checks to make sure they are not pointing into SMRAM.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Fujitsu PSIRT is notified                | 2021-09-10    |
| Fujitsu PSIRT is confirmed issue         | 2021-09-14    |
| CERT/CC created a case                   | 2021-09-27    |
| Insyde PSIRT assigned CVE number         | 2021-11-01    |
| Insyde PSIRT provide patch release       | 2021-11-09    |
| BINARLY public disclosure date           | 2022-02-01    |

## Acknowledgements

**BINARLY efiXplorer team**
