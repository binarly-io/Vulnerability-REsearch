# [BRLY-2021-046]

# SMM callout vulnerability in SMM driver on HP device (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified SMM callout on HP device, which allows a attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-046
* HP PSIRT assigned CVE identifier: [CVE-2022-31640](https://support.hp.com/us-en/document/ish_6662920-6662944-16/hpsbhf03805)
* CVSS v3.1: 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Intel firmware with confirmed impact by Binarly team

| Device/Firmware | File Name | SHA256 (File PE32 section) | File GUID |
| --- | --- | --- | --- |
| HP EliteBook x360 1040 G8 | FFFF | 17268b873c33f25ce0f2b6f7db60b13021765ce1db3755c9c7edfe8e714474d7 | 3F6A87A5-A33F-4B9A-A3D2-32D5B18BF6FF |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an evironment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into BIOS. Such a malicious firmware code in BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by malicious actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerability exists in child SW SMI handler registered with GUID `b62bcc9c-6bcb-4707-b365-b8cd40cf0652` and located at offset `0x19C4` in the binary.
The pseudocode for this handler is shown below:

```c++
EFI_STATUS __fastcall SmiHandler(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( !CheckInput(CommBuffer, CommBufferSize) )
  {
    if ( !*(CommBuffer + 16) )
    {
      Status = sub_17D8(*CommBuffer);
      goto _Exit;
    }
    if ( *(CommBuffer + 16) == 1 )
    {
      if ( *CommBuffer )
      {
        Status = sub_181C(**CommBuffer);
        goto _Exit;
      }
    }
    else
    {
      if ( *(CommBuffer + 16) == 2 )
      {
        Status = sub_18E0(*CommBuffer);
        goto _Exit;
      }
      if ( *(CommBuffer + 16) != 3 )
      {
        if ( *(CommBuffer + 16) == 4 )
        {
          Status = sub_1938(*CommBuffer);
        }
        else if ( *(CommBuffer + 16) == 5 )
        {
          Status = sub_198C(*(CommBuffer + 16) - 4, v5, v6);
        }
        else
        {
          Status = EFI_UNSUPPORTED;
        }
        goto _Exit;
      }
      if ( *CommBuffer )
      {
        Status = (ProprietaryProtocol3Interface->Func2)(&gGuid_0, **CommBuffer);
_Exit:
        *(CommBuffer + 3) = Status;
        return 0;
      }
    }
    Status = EFI_INVALID_PARAMETER;
    goto _Exit;
  }
  return 0;
}
```

If `( *((_BYTE *)CommBuffer + 16)` equal to `0x01`, and pointer extracted from CommBuffer is not zero (`*(_QWORD *)CommBuffer`) the following code will be triggered:

```c++
__int64 __fastcall sub_181C(unsigned int CbValue)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  Value1 = 0;
  Value2 = 0;
  Flag = 0;
  if ( !(ProprietaryProtocol3Interface->Func1)(&gGuid_0, &Value1)
    && !(ProprietaryProtocol3Interface->Func3)(&gGuid_0, &Value2) )
  {
    Flag = Value1 != Value2;
  }
  Res = (ProprietaryProtocol3Interface->Func4)(&gGuid_0, CbValue);
  if ( !Res )
  {
    Res = (ProprietaryProtocol3Interface->Func6)(&gGuid_0, CbValue);
    if ( !Res && Flag )
    {
      EfiPcdProtocol = LocateEfiPcdProtocol();
      LOBYTE(Value) = 1;
      (EfiPcdProtocol->SetBool)(&gGuid, 0x40000002, Value);
    }
  }
  return Res;
}
```

The pseudocode of the `LocateEfiPcdProtocol` function is shown below:

```c++
EFI_PCD_PROTOCOL *LocateEfiPcdProtocol()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  result = gEfiPcdProtocol;
  if ( !gEfiPcdProtocol )
  {
    gBS->LocateProtocol(&EFI_PCD_PROTOCOL_GUID, 0, &gEfiPcdProtocol);
    return gEfiPcdProtocol;
  }
  return result;
}
```

As we can see, if `Func1`, `Func3`, `Func4`, `Func6` are executed without errors and `Value1` is not equal to `Value2`, the protocol interface `EFI_PCD_PROTOCOL` will be located (via `gBS->LocateProtocol` call) and the `SetBool` function from the protocol will be called.

This means that a potential attacker could overwrite the `gBS->LocateProtocol` pointer in the `EFI_BOOT_SERVICES` table with the shellcode address and trigger this handler. As a result, it will execute arbitrary code in SMRAM.

If the `EFI_PCD_PROTOCOL` interface is already located (`gEfiPcdProtocol` is not NULL), a potential attacker could overwrite not the `gBS->LocateProtocol` pointer, but the `gEfiPcdProtocol->SetBool` pointer.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| HP PSIRT is notified                     | 2021-07-12    |
| HP PSIRT confirmed reported issue        | 2021-08-09    |
| HP PSIRT assigned CVE number             | 2021-08-19    |
| CERT/CC created a case                   | 2021-11-16    |
| HP PSIRT provide patch release           | 2022-03-08    |
| BINARLY public disclosure date           | 2022-03-08    |

## Acknowledgements

**BINARLY efiXplorer team**
