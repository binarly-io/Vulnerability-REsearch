# [BRLY-2022-017]
# SMM callout vulnerability in SMM driver (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified an SMM callout, which allows an attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2022-017
* Insyde PSIRT assigned CVE identifier: CVE-2022-36338
* FwHunt rule: [BRLY-2022-017](https://github.com/binarly-io/FwHunt/blob/main/rules/Vulnerabilities/Insyde/BRLY-2022-017.yml)
* CVSS v3.1 7.5 High AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected HP firmware with confirmed impact by Binarly team

| Fimware | Module name | Module SHA256 | File GUID |
| --- | --- | --- | --- |
| Framework_Laptop_12th_Gen_Intel_Core_capsule_EFI_signed_allsku_3.01.bin | FwBlockServiceSmm | 76FA6B5D3F5E59FCD3CA6CDEF9B9D8F0C9B879AF13EFE25CF3E208B7358A6D0B | 74D936FA-D8BD-4633-B64D-6424BDD23D24 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an evironment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability potentially could be used by threat actors to bypass security mechanisms provided by the UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

The vulnerable module registers a child SW SMI handler with GUID `2970687c-618c-4de5-b8f9-6c7576dca83d`:

```C++
gSmst->SmiHandlerRegister)(SmiHandler, &UNKNOWN_PROTOCOL_2970687C_GUID, &Handle);
```

The handler is located at offset `0x19D0`:

```C++
EFI_STATUS __fastcall SmiHandler(EFI_HANDLE DispatchHandle, const void *Context, void *CommBuffer, UINTN *CommBufferSize)
{
  if ( CommBuffer && CommBufferSize && !gExitBootServicesFlag2EfiEventLegacyBootFlag )
  {
    if ( !gUnknownProtocol74d936fa )
    {
      if (gEfiBootServices->LocateProtocol)(&UNKNOWN_PROTOCOL_74D936FA_GUID, 0, &gUnknownProtocol74d936fa) < 0 )
        return 0;
```

As we can see before `EFI_EVENT_EXIT_BOOT_SERVICES` is triggered, the handler will try to locate protocol `74d936fa-d8bd-4633-b64d-6424bdd23d24` using the `EFI_BOOT_SERVICES` which is located outside of SMRAM, hence this call could be hijacked by a possible attacker.

Despite the vulnerability cannot be exploited from the operating system, using `EFI_BOOT_SERVICES` and `EFI_RUNTIME_SERVICES` is unsafe inside a code intended to run in SMM (from SMRAM) because an attacker capable of executing code in DXE phase could exploit this vulnerability to escalate privileges to SMM (ring -2).

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Framework PSIRT is notified              | 2022-06-27    |
| Insyde PSIRT confirmed reported issue    | 2022-07-19    |
| Insyde PSIRT assigned CVE number         | 2022-07-25    |
| BINARLY public disclosure date           | 2022-09-21    |

## Acknowledgements

**BINARLY efiXplorer team**
