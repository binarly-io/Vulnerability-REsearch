# [BRLY-2021-017]

# SMM callout vulnerability in combined DXE/SMM on Fujitsu device (SMM arbitrary code execution).

## Summary

**BINARLY efiXplorer team** identified a SMM callout in a Fujitsu device, which allows an attacker to access the System Management Mode and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-017
* CERT/CC assigned case number: [VU#796611](https://kb.cert.org/vuls/id/796611)
* Insyde PSIRT assigned CVE identifier: [CVE-2021-41839](https://www.insyde.com/security-pledge/SA-2022020)
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Fujitsu firmware with confirmed impact by BINARLY team

| Device name | Driver name | Driver SHA256 | File GUID |
| --- | --- | --- | --- |
| Fujitsu LIFEBOOK E459/E449 | NvmExpressDxe | f6d7d5cce1a3b2ebe9825c195f61f36aca674e3710abf0e24f1383e6d3c0e126 | 5BE3BDF4-53CF-46A3-A6A9-73C34A6E5EE3 |

## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability could potentially be used by threat actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

In the function at offset `0x1AC0` (image sha256: `f6d7d5cce1a3b2ebe9825c195f61f36aca674e3710abf0e24f1383e6d3c0e126`), the child software System Management Interrupt (SWSMI) handler with the GUID `EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID` is registered:

```c++
if ( SmstIsNotNull() )
{
  DispatchHandle = 0;
  gSmst_62B0->SmiHandlerRegister(SmiHandler_17D4, &EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID_5AF0, &DispatchHandle);
  Registration = 0;
  result = gSmst_62B0->SmmRegisterProtocolNotify(&ProprietaryProtocol_5B80, Function, &Registration);
  if ( result < 0 )
    return result;
}
```

Find below the decompiled SWSMI handler code:

```c++
__int64 __fastcall SmiHandler_17D4(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( !CommBuffer || !CommBufferSize )
    return 0;
  if ( *CommBuffer != 1 )
    return EFI_UNSUPPORTED;
  SourceSize = 0;
  if ( (gBS_6278->LocateHandleBuffer(
          ByProtocol,
          &EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID_5AF0,
          0,
          &NoHandles,
          &SourceSize) & 0x8000000000000000) != 0 )
    return EFI_NOT_FOUND;
  Buffer = SourceSize;
  if ( SourceSize )
  {
    gBS_6278->FreePool(SourceSize);
    Buffer = 0;
    SourceSize = 0;
  }
  BufferSize = 0;
  Status = gSmst_62B0->SmmLocateHandle(
             ByProtocol,
             &EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID_5AF0,
             0,
             &BufferSize,
             Buffer);
  if ( Status )
  {
    if ( Status == EFI_BUFFER_TOO_SMALL )
    {
      gSmst_62B0->SmmAllocatePool(EfiRuntimeServicesData, BufferSize, &SourceSize);
      if ( !SourceSize )
        return EFI_OUT_OF_RESOURCES;
      Status = gSmst_62B0->SmmLocateHandle(
                 ByProtocol,
                 &EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID_5AF0,
                 0,
                 &BufferSize,
                 SourceSize);
    }
    else if ( Status != EFI_NOT_FOUND )
    {
      return EFI_NOT_FOUND;
    }
  }
  Res = Status == EFI_NOT_FOUND ? 0 : BufferSize >> 3;
  gSmst_62B0->SmmFreePool(SourceSize);
  if ( Res == NoHandles )
    return 0;
  result = sub_428();
  if ( result >= 0 )
    return 0;
  if ( result == EFI_NOT_STARTED )
    return 0;
  return result;
}
```

If `CommBuffer` and `CommBufferSize` pointers are not-NULL and first QWORD from `CommBuffer` is equal to `0x01`, the following code will be executed:

```c++
if ( (gBS_6278->LocateHandleBuffer(
        ByProtocol,
        &EFI_NVM_EXPRESS_PASS_THRU_PROTOCOL_GUID_5AF0,
        0,
        &NoHandles,
        &SourceSize) & 0x8000000000000000) != 0 )
  return EFI_NOT_FOUND;
```

Using services from `EFI_BOOT_SERVICES` (in this case `LocateHandleBuffer()`) inside a SW SMI handler is unsafe and may lead to arbitrary code execution in SMM.

In addition to this code, this SMI handler uses the following services in the `EFI_BOOT_SERVICES` table:

* `SmiHandler()` -> `gBS->FreePool()`
* `SmiHandler()` -> `sub_428()` -> `gBS->LocateHandleBuffer()`
* `SmiHandler()` -> `sub_428()` -> `gBS->HandleProtocol()`

Each of these services can be targeted by a potential attacker. 

To exploit this vulnerability is enough to:

* overwrite the `LocateHandleBuffer()`, `FreePool()` or `HandleProtocol()` service address in the `EFI_BOOT_SERVICES` table with the shellcode address
* trigger the SWSMI handler (SwSmi number is specified in UEFI ACPI table)

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Fujitsu PSIRT is notified                | 2021-09-10    |
| Fujitsu PSIRT is confirmed issue         | 2021-09-14    |
| CERT/CC created a case                   | 2021-09-27    |
| Insyde PSIRT assigned CVE number         | 2021-11-01    |
| Insyde PSIRT provide patch release       | 2021-11-09    |
| BINARLY public disclosure date           | 2022-02-01    |

## Acknowledgements

**BINARLY efiXplorer team**
