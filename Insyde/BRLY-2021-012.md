# [BRLY-2021-012]

# SMM memory corruption vulnerability in combined DXE/SMM driver on Fujitsu device (SMRAM write).

## Summary

**BINARLY efiXplorer team** has discovered a SMM memory corruption vulnerability in Fujitsu devices allowing a possible attacker to write data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2021-012
* CERT/CC assigned case number: [VU#796611](https://kb.cert.org/vuls/id/796611)
* Insyde PSIRT assigned CVE identifier: CVE-2021-45971
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Fujitsu firmwares with confirmed impact by BINARLY team

| Device name | Driver name | Driver SHA256 | File GUID |
| --- | --- | --- | --- |
| Fujitsu LIFEBOOK A3510 | SdHostDriver | fa9d63c831354c494ce14c87757c43936d1c634779997a8cc77ec71cb9a307ca | 67BBC344-84BC-4E5C-B4DF-F5E4A00E1F3A |
| Fujitsu LIFEBOOK U9310 | SdHostDriver | fa9d63c831354c494ce14c87757c43936d1c634779997a8cc77ec71cb9a307ca | 67BBC344-84BC-4E5C-B4DF-F5E4A00E1F3A |
| Fujitsu LIFEBOOK E5510/E5410 | SdHostDriver | fa9d63c831354c494ce14c87757c43936d1c634779997a8cc77ec71cb9a307ca | 67BBC344-84BC-4E5C-B4DF-F5E4A00E1F3A |
| Fujitsu LIFEBOOK U7510/U7410/U7310 | SdHostDriver | fa9d63c831354c494ce14c87757c43936d1c634779997a8cc77ec71cb9a307ca | 67BBC344-84BC-4E5C-B4DF-F5E4A00E1F3A |
| Fujitsu LIFEBOOK E459/E449 | SdHostDriver | a6f1c365d80a77c85964a4dd477e4986e20d296ae8744c7ef33931e24cfcbb3f | 67BBC344-84BC-4E5C-B4DF-F5E4A00E1F3A |


## Potential impact

An attacker can exploit this vulnerability to elevate privileges from ring 0 to ring -2, execute arbitrary code in System Management Mode - an environment more privileged than operating system (OS) and completely isolated from it. Running arbitrary code in SMM additionally bypasses SMM-based SPI flash protections against modifications, which can help an attacker to install a firmware backdoor/implant into the BIOS. Such a malicious firmware code in the BIOS could persist across operating system re-installs. Additionally, this vulnerability could potentially be used by threat actors to bypass security mechanisms provided by UEFI firmware (for example, Secure Boot and some types of memory isolation for hypervisors).

## Vulnerability description

In the function at offset `0x1E78` (image sha256: `fa9d63c831354c494ce14c87757c43936d1c634779997a8cc77ec71cb9a307ca`), the child software System Management Interrupt (SWSMI) handler with GUID `3779ad93-b988-43bc-91f0-3b6c6e38fadb` is registered:

```c++
if ( v5 )
{
  result = gBS_B588->LocateProtocol(&gSmiHandlerGuid, 0, &Buffer);
  if ( result >= 0 )
  {
    result = gSmst_B5C8->SmiHandlerRegister(SmiHandler_296C, &gSmiHandlerGuid, &DispatchHandle);
    if ( result >= 0 )
    {
      v7 = (gSmst_B5C8->SmmRegisterProtocolNotify)(&Protocol, Function, v11);
      if ( v7 < 0 )
        return v7;
      return v4;
    }
  }
}
```

Find below the decompiled SWSMI handler code:

```c++
EFI_STATUS __fastcall SmiHandler_296C(
        EFI_HANDLE DispatchHandle,
        const void *Context,
        void *CommBuffer,
        UINTN *CommBufferSize)
{
  EFI_STATUS Status; // rax

  if ( CommBuffer && CommBufferSize )
  {
    if ( *CommBuffer )
    {
      Status = EFI_UNSUPPORTED;
    }
    else if ( *(CommBuffer + 2) == 0x148 )
    {
      Status = sub_27CC(0, CommBuffer + 0x18);
    }
    else
    {
      Status = EFI_INVALID_PARAMETER;
    }
    *(CommBuffer + 1) = Status;
  }
  return 0;
}
```

If `CommBuffer` and `CommBufferSize` pointers are not NULL, the status code is written to the second QWORD in the CommBuffer (`*(CommBuffer + 1)`).

In addition, if the third QWORD from the CommBuffer is 0x148, the `sub_27CC` function is called. Consider the following decompiled code of this function:

```c++
EFI_STATUS __fastcall sub_27CC(__int64 a1, void *CommBufferData)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( *((_BYTE *)CommBufferData + 0xE0) )
    return 0;
  Interface = 0;
  Buffer = 0;
  Status = gSmst_B5C8->SmmAllocatePool(EfiRuntimeServicesData, 0x148, &Buffer);
  if ( (Status & 0x8000000000000000) != 0 )
    goto _FreeBufferAndExit1;
  ZeroMem(Buffer, 0x148);
  CopyMem(Buffer, CommBufferData, 0x148);
  *((_QWORD *)Buffer + 3) = 0;
  Status = InstallProprietaryProtocolInterface((__int64)Buffer);
  if ( (Status & 0x8000000000000000) == 0 )
  {
    ...
    Status = gSmst_B5C8->SmmInstallProtocolInterface(
               (EFI_HANDLE *)Buffer + 3,
               &EFI_DEVICE_PATH_PROTOCOL_GUID_B000,
               EFI_NATIVE_INTERFACE,
               Interface);
    if ( (Status & 0x8000000000000000) == 0 )
    {
      v7 = Buffer;
      *((_QWORD *)CommBufferData + 3) = *((_QWORD *)Buffer + 3);
      *((_BYTE *)CommBufferData + 0xE0) = 1;
      v7[224] = 1;
      return Status;
    }
_FreeBufferAndExit1:
    Interface1 = Interface;
    goto _FreeBufferAndExit;
  }
  ((void (__fastcall *)(void *))gSmst_B5C8->SmmFreePool)(Buffer);
  return Status;
}
```

`CommBufferData` - data located at offset 0x18 relative to the beginning of the `CommBuffer`.
From the pseudocode, one can infer the following:
* at offset `3 * 8` relative to the beginning of `CommBufferData`, the value `*((_QWORD *)Buffer + 3)` can be written (8 bytes)
* at offset `0xE0` relative to the beginning of `CommBufferData`, the value `0x01` can be written (1 byte)

There is no pointer validation carried out (to ensure `CommBufferData` and any other Communication Buffer nested contents are not pointing to SMRAM contents). Thus, a potential attacker can write fixed data to SMRAM to corrupt some data inside this memory (for example, change SMI handler's code or modify Smram Map structures to break input pointer validation for other SMI handlers, hence to completely make this mitigation inefficient). This could lead to gaining arbitrary code execution in SMM.

To fix this vulnerability, it is essential to wrap all the input pointers (including the nested pointers) for SMI handlers with sanity checks to make sure they are not pointing into SMRAM.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity                      | Date          |
| ---------------------------------------- | ------------- |
| Fujitsu PSIRT is notified                | 2021-09-10    |
| Fujitsu PSIRT is confirmed issue         | 2021-09-14    |
| CERT/CC created a case                   | 2021-09-27    |
| Insyde PSIRT assigned CVE number         | 2021-11-01    |
| Insyde PSIRT provide patch release       | 2021-11-09    |
| BINARLY public disclosure date           | 2022-02-01    |

## Acknowledgements

**BINARLY efiXplorer team**
